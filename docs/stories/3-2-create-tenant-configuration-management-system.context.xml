<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.2</storyId>
    <title>Create Tenant Configuration Management System</title>
    <status>drafted</status>
    <generatedAt>2025-11-02</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/3-2-create-tenant-configuration-management-system.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>operations engineer</asA>
    <iWant>tenant-specific configuration stored and loaded per request</iWant>
    <soThat>each client can have unique ServiceDesk Plus credentials and preferences</soThat>
    <tasks>
      <task id="1" ac="1">Extend Database Schema and Models
        <subtask id="1.1">Create Alembic migration for tenant_configs schema updates</subtask>
        <subtask id="1.2">Update SQLAlchemy model at src/database/models.py</subtask>
        <subtask id="1.3">Create Pydantic schemas at src/schemas/tenant.py</subtask>
        <subtask id="1.4">Test migration on local database</subtask>
      </task>
      <task id="2" ac="1,2">Implement Encryption for Sensitive Fields
        <subtask id="2.1">Create encryption utility at src/utils/encryption.py</subtask>
        <subtask id="2.2">Update .env.example with ENCRYPTION_KEY placeholder</subtask>
        <subtask id="2.3">Write unit tests for encryption at tests/unit/test_encryption.py</subtask>
      </task>
      <task id="3" ac="2,3">Create Tenant Service with Caching
        <subtask id="3.1">Implement TenantService at src/services/tenant_service.py</subtask>
        <subtask id="3.2">Configure Redis connection at src/cache/redis_client.py</subtask>
        <subtask id="3.3">Write unit tests for TenantService at tests/unit/test_tenant_service.py</subtask>
      </task>
      <task id="4" ac="4,6">Create FastAPI Dependency for Tenant Config
        <subtask id="4.1">Implement dependency at src/api/dependencies.py</subtask>
        <subtask id="4.2">Update webhook endpoint at src/api/webhooks.py</subtask>
        <subtask id="4.3">Write integration tests at tests/integration/test_tenant_dependency.py</subtask>
      </task>
      <task id="5" ac="5">Implement Admin CRUD API Endpoints
        <subtask id="5.1">Create admin routes at src/api/admin/tenants.py</subtask>
        <subtask id="5.2">Implement admin authentication middleware</subtask>
        <subtask id="5.3">Include router in main FastAPI app (src/main.py)</subtask>
        <subtask id="5.4">Write integration tests for admin API at tests/integration/test_admin_tenants.py</subtask>
      </task>
      <task id="6" ac="6">Update Celery Tasks for Tenant Config
        <subtask id="6.1">Modify enhance_ticket task at src/workers/tasks.py</subtask>
        <subtask id="6.2">Update ServiceDesk Plus API client at src/enhancement/ticket_updater.py</subtask>
        <subtask id="6.3">Test Celery task with tenant config</subtask>
      </task>
      <task id="7" ac="7">Comprehensive Testing and Documentation
        <subtask id="7.1">Run full test suite</subtask>
        <subtask id="7.2">Performance testing for caching</subtask>
        <subtask id="7.3">Security testing</subtask>
        <subtask id="7.4">Update documentation</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Tenant Configuration Model Extended
      - tenant_configs table includes all required fields with proper types
      - Encryption implemented for sensitive fields using cryptography library
      - JSONB enhancement_preferences field supports flexible configuration
      - SQLAlchemy model with proper type hints and relationships
    </criterion>
    <criterion id="2">Configuration Loader Service Implemented
      - TenantService class with async get_tenant_config method
      - Decryption handled transparently
      - Pydantic validation and type safety
      - Error handling for missing tenants
    </criterion>
    <criterion id="3">Redis Caching Layer
      - Configurations cached with 5-minute TTL
      - Cache invalidation on updates
      - Graceful fallback if Redis unavailable
      - Redis connection pooling configured
    </criterion>
    <criterion id="4">FastAPI Dependency Injection
      - Dependency extracts tenant_id and returns config
      - Integration with RLS tenant context (Story 3.1)
      - Proper HTTP exceptions for errors
    </criterion>
    <criterion id="5">Configuration CRUD API Endpoints
      - POST/GET/PUT/DELETE /admin/tenants endpoints
      - Admin authentication required
      - Sensitive fields masked in responses
      - Request/response validation
    </criterion>
    <criterion id="6">Webhook Integration
      - Webhooks use tenant configuration dependency
      - ServiceDesk Plus credentials from tenant config
      - Enhancement preferences applied
      - Tenant context set for RLS
    </criterion>
    <criterion id="7">Comprehensive Testing
      - Unit tests for TenantService, encryption, validation
      - Integration tests for API, webhooks, caching
      - Performance test: cache hit ratio >90%
      - Security test: encrypted fields never exposed
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Data Architecture - Tenant Configuration Table</section>
        <snippet>Defines tenant_configs table schema with id (UUID), tenant_id (VARCHAR 100), name, servicedesk_url, api_key_encrypted, webhook_secret_encrypted, enhancement_preferences (JSONB). Includes indexes for performance.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Multi-Tenancy Requirements (FR018-FR021)</section>
        <snippet>FR019: System shall load tenant-specific configuration (API credentials, enhancement preferences) from database. FR020: Support different ServiceDesk Plus instances per tenant. NFR004: Encrypt credentials at rest.</snippet>
      </doc>
      <doc>
        <path>docs/security-rls.md</path>
        <title>Row-Level Security Implementation</title>
        <section>Application Integration</section>
        <snippet>Documents set_db_tenant_context() function for setting RLS session variable. FastAPI dependency pattern using get_tenant_db. Tenant context must be set before queries on RLS-protected tables.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Definitions</title>
        <section>Epic 3: Multi-Tenancy & Security - Story 3.2</section>
        <snippet>Configuration loader retrieves tenant config by tenant_id. Config cached in Redis with 5-minute TTL. Configuration CRUD API endpoints (admin only). Tenant ID extracted from webhook payload or auth token.</snippet>
      </doc>
      <doc>
        <path>external:web</path>
        <title>Building Scalable Multi-Tenant Architectures in FastAPI</title>
        <section>Best Practices (python.plainenglish.io)</section>
        <snippet>Use FastAPI dependencies to inject tenant context per request. Validate tenant existence before processing. Combine with RLS for defense-in-depth. Cache tenant configurations with 5-10 minute TTL, invalidate on updates, monitor cache hit ratio (target >90%).</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/database/models.py</path>
        <kind>model</kind>
        <symbol>TenantConfig</symbol>
        <lines>29-103</lines>
        <reason>Existing TenantConfig model with all required fields already defined. Story extends this with encryption layer and service logic.</reason>
      </artifact>
      <artifact>
        <path>src/database/tenant_context.py</path>
        <kind>utility</kind>
        <symbol>set_db_tenant_context</symbol>
        <lines>15-46</lines>
        <reason>RLS context management function from Story 3.1. Must be called after loading tenant config to ensure database-level isolation.</reason>
      </artifact>
      <artifact>
        <path>src/api/dependencies.py</path>
        <kind>dependency</kind>
        <symbol>get_tenant_id, get_tenant_db</symbol>
        <lines>1-50</lines>
        <reason>Existing FastAPI dependencies for tenant identification and RLS-aware database sessions. Story extends with get_tenant_config_dep.</reason>
      </artifact>
      <artifact>
        <path>src/cache/redis_client.py</path>
        <kind>client</kind>
        <symbol>get_redis_client</symbol>
        <lines>19-41</lines>
        <reason>Existing Redis client with connection pooling. Story adds tenant config caching methods (set, get, invalidate).</reason>
      </artifact>
      <artifact>
        <path>src/api/webhooks.py</path>
        <kind>endpoint</kind>
        <symbol>webhook endpoints</symbol>
        <lines>1-100</lines>
        <reason>Webhook receiver endpoints. Story updates to use tenant config dependency for credentials and preferences.</reason>
      </artifact>
      <artifact>
        <path>tests/fixtures/rls_fixtures.py</path>
        <kind>test-fixture</kind>
        <symbol>multi-tenant test fixtures</symbol>
        <lines>1-50</lines>
        <reason>Reusable test fixtures for multi-tenant scenarios from Story 3.1. Use for tenant config tests.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="fastapi" version=">=0.104.0">Web framework for API endpoints</package>
        <package name="pydantic" version=">=2.5.0">Data validation and settings management</package>
        <package name="sqlalchemy[asyncio]" version=">=2.0.23">ORM with async support</package>
        <package name="redis" version=">=5.0.1">Caching layer</package>
        <package name="cryptography" version=">=41.0.0">Fernet encryption for sensitive fields</package>
        <package name="pytest" version=">=7.4.3">Testing framework</package>
        <package name="pytest-asyncio" version=">=0.21.1">Async test support</package>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architectural">Must integrate with Story 3.1 RLS implementation - call set_db_tenant_context() after loading tenant config</constraint>
    <constraint type="security">All sensitive fields (api_key, webhook_secret) must be encrypted at rest using cryptography.fernet</constraint>
    <constraint type="security">Never return decrypted credentials in GET responses - always mask with ***encrypted***</constraint>
    <constraint type="performance">Cache tenant configs in Redis with 5-minute TTL, target >90% cache hit ratio</constraint>
    <constraint type="pattern">Use FastAPI dependency injection for tenant config loading in endpoints</constraint>
    <constraint type="pattern">Follow existing async/await patterns with SQLAlchemy 2.0 AsyncSession</constraint>
    <constraint type="testing">Maintain >80% code coverage for all new tenant management components</constraint>
    <constraint type="validation">Tenant ID format: lowercase alphanumeric + hyphens only (regex: ^[a-z0-9\-]+$)</constraint>
    <constraint type="data">Use Pydantic models for all API request/response validation</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>TenantService.get_tenant_config</name>
      <kind>async method</kind>
      <signature>async def get_tenant_config(tenant_id: str) -> TenantConfig</signature>
      <path>src/services/tenant_service.py (to be created)</path>
      <description>Primary method for loading tenant configuration. Checks Redis cache first, falls back to database. Returns decrypted credentials.</description>
    </interface>
    <interface>
      <name>get_tenant_config_dep</name>
      <kind>FastAPI dependency</kind>
      <signature>async def get_tenant_config_dep(tenant_id: str, db: AsyncSession, redis: Redis) -> TenantConfig</signature>
      <path>src/api/dependencies.py (to be added)</path>
      <description>FastAPI dependency that loads tenant config and sets RLS context. Use in webhook and API endpoints.</description>
    </interface>
    <interface>
      <name>POST /admin/tenants</name>
      <kind>REST API</kind>
      <signature>Request: TenantConfigCreate, Response: TenantConfigResponse (201)</signature>
      <path>src/api/admin/tenants.py (to be created)</path>
      <description>Create new tenant configuration. Encrypts sensitive fields before storage. Requires admin authentication.</description>
    </interface>
    <interface>
      <name>GET /admin/tenants/{tenant_id}</name>
      <kind>REST API</kind>
      <signature>Response: TenantConfigResponse (200)</signature>
      <path>src/api/admin/tenants.py (to be created)</path>
      <description>Retrieve tenant configuration. Sensitive fields masked in response.</description>
    </interface>
    <interface>
      <name>encrypt / decrypt</name>
      <kind>utility functions</kind>
      <signature>def encrypt(plaintext: str) -> str, def decrypt(ciphertext: str) -> str</signature>
      <path>src/utils/encryption.py (to be created)</path>
      <description>Symmetric encryption/decryption using Fernet. Key loaded from ENCRYPTION_KEY env variable.</description>
    </interface>
  </interfaces>
  <tests>
    <standards>
Project uses pytest with pytest-asyncio for async support. Test structure: tests/unit/ for isolated component tests, tests/integration/ for multi-component interactions, tests/fixtures/ for reusable test data. Coverage target: >80% for new code. Existing fixtures in tests/fixtures/rls_fixtures.py provide multi-tenant test scenarios. Use FastAPI TestClient for API endpoint tests. Mock external dependencies (Redis, database) in unit tests, use real instances in integration tests.
    </standards>
    <locations>
tests/unit/test_encryption.py
tests/unit/test_tenant_service.py
tests/integration/test_admin_tenants.py
tests/integration/test_tenant_dependency.py
tests/fixtures/rls_fixtures.py (reuse existing)
    </locations>
    <ideas>
      <idea ac="1">Test TenantConfig model validation - valid data accepted, invalid tenant_id format rejected</idea>
      <idea ac="1,2">Test encryption round-trip - encrypt(plaintext) then decrypt returns original value</idea>
      <idea ac="2">Test encryption key missing - raises ValueError when ENCRYPTION_KEY not set</idea>
      <idea ac="2,3">Test TenantService.get_tenant_config with cache hit - Redis returns cached config, database not queried</idea>
      <idea ac="2,3">Test TenantService.get_tenant_config with cache miss - queries database, caches result</idea>
      <idea ac="3">Test cache invalidation on update - PUT /admin/tenants/{id} clears Redis cache</idea>
      <idea ac="3">Test graceful Redis fallback - if Redis unavailable, skip caching but continue operation</idea>
      <idea ac="4">Test get_tenant_config_dep extracts tenant_id from webhook payload</idea>
      <idea ac="4">Test get_tenant_config_dep sets RLS context after loading config</idea>
      <idea ac="4">Test get_tenant_config_dep raises 404 for non-existent tenant</idea>
      <idea ac="5">Test POST /admin/tenants - creates tenant, returns masked credentials in response</idea>
      <idea ac="5">Test POST /admin/tenants with duplicate tenant_id - returns 409 Conflict</idea>
      <idea ac="5">Test GET /admin/tenants - returns paginated list with masked sensitive fields</idea>
      <idea ac="5">Test admin endpoints without API key - returns 401 Unauthorized</idea>
      <idea ac="6">Test webhook processing with tenant config - uses tenant-specific credentials</idea>
      <idea ac="6">Test webhook applies enhancement preferences from tenant config</idea>
      <idea ac="7">Performance test - measure cache hit ratio for 100 repeated get_tenant_config calls (target >90%)</idea>
      <idea ac="7">Security test - verify GET responses never contain plaintext api_key or webhook_secret</idea>
      <idea ac="7">Security test - verify cross-tenant isolation - tenant A cannot access tenant B config via API</idea>
    </ideas>
  </tests>
</story-context>
