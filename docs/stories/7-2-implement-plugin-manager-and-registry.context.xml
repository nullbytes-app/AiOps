<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>7</epicId>
    <storyId>2</storyId>
    <title>Implement Plugin Manager and Registry</title>
    <status>drafted</status>
    <generatedAt>2025-11-04</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/7-2-implement-plugin-manager-and-registry.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>platform engineer</asA>
    <iWant>a plugin manager that loads and routes requests to appropriate plugins</iWant>
    <soThat>the system can dynamically support multiple ticketing tools</soThat>
    <tasks>
### Task 1: Create Plugin Registry Infrastructure (AC: #1)
- [ ] 1.1 Create `src/plugins/registry.py` file with module docstring
- [ ] 1.2 Import required types: TicketingToolPlugin, Dict, Type, Optional
- [ ] 1.3 Define `PluginNotFoundError` exception class
- [ ] 1.4 Define `PluginValidationError` exception class
- [ ] 1.5 Add copyright header and module-level documentation

### Task 2: Implement PluginManager Class with Singleton Pattern (AC: #1)
- [ ] 2.1 Define `PluginManager` class with `__init__` method
- [ ] 2.2 Implement singleton pattern using `__new__` method or class variable
- [ ] 2.3 Initialize internal registry: `_plugins: Dict[str, TicketingToolPlugin] = {}`
- [ ] 2.4 Add class-level docstring explaining singleton pattern and usage
- [ ] 2.5 Add `_instance` class variable for singleton instance tracking

### Task 3: Implement Plugin Registration (AC: #2, #6)
- [ ] 3.1 Define `register_plugin(tool_type: str, plugin: TicketingToolPlugin)` method
- [ ] 3.2 Add validation: Check plugin is instance of TicketingToolPlugin
- [ ] 3.3 Add validation: Check all abstract methods are implemented (using ABC)
- [ ] 3.4 Add validation: Check tool_type is non-empty string
- [ ] 3.5 Store plugin in `_plugins` dictionary with tool_type as key
- [ ] 3.6 Add comprehensive Google-style docstring with examples
- [ ] 3.7 Raise PluginValidationError if validation fails with descriptive message
- [ ] 3.8 Log successful registration at INFO level

### Task 4: Implement Plugin Retrieval (AC: #3, #5)
- [ ] 4.1 Define `get_plugin(tool_type: str) -> TicketingToolPlugin` method
- [ ] 4.2 Lookup tool_type in `_plugins` dictionary
- [ ] 4.3 Return plugin if found
- [ ] 4.4 Raise PluginNotFoundError if tool_type not registered
- [ ] 4.5 Include list of registered plugins in error message for debugging
- [ ] 4.6 Add comprehensive Google-style docstring
- [ ] 4.7 Add type hints for mypy validation

### Task 5: Implement Plugin Discovery (AC: #4)
- [ ] 5.1 Define `discover_plugins()` method for automatic loading
- [ ] 5.2 Scan `src/plugins/*/` directories for `plugin.py` files
- [ ] 5.3 Use `importlib` to dynamically import plugin modules
- [ ] 5.4 Detect classes inheriting from TicketingToolPlugin
- [ ] 5.5 Instantiate discovered plugin classes
- [ ] 5.6 Auto-register discovered plugins using tool_type from class metadata
- [ ] 5.7 Handle import errors gracefully (log warning, continue discovery)
- [ ] 5.8 Add `load_plugins_on_startup()` convenience method
- [ ] 5.9 Document discovery conventions in docstring (naming, structure)

### Task 6: Add Helper Methods (Utilities)
- [ ] 6.1 Implement `list_registered_plugins() -> List[str]` to return all tool_types
- [ ] 6.2 Implement `is_plugin_registered(tool_type: str) -> bool` for checking
- [ ] 6.3 Implement `unregister_plugin(tool_type: str)` for testing/hot-reload
- [ ] 6.4 Add Google-style docstrings for all helper methods
- [ ] 6.5 Add type hints for all methods

### Task 7: Type Safety with TYPE_CHECKING Guards (AC: #6)
- [ ] 7.1 Import TYPE_CHECKING from typing module
- [ ] 7.2 Use TYPE_CHECKING guard for static imports of plugin types
- [ ] 7.3 Add runtime type validation using `isinstance()` checks
- [ ] 7.4 Ensure mypy validates plugin interface compliance
- [ ] 7.5 Test with mypy strict mode enabled

### Task 8: Create Unit Tests for PluginManager (AC: #7)
- [ ] 8.1 Create `tests/unit/test_plugin_registry.py` file
- [ ] 8.2 Import pytest, PluginManager, Mock TicketingToolPlugin
- [ ] 8.3 Create fixture: `plugin_manager` (returns fresh PluginManager instance)
- [ ] 8.4 Create fixture: `mock_plugin` (MockTicketingToolPlugin from Story 7.1)
- [ ] 8.5 Write test: `test_plugin_manager_singleton()` - verify single instance
- [ ] 8.6 Write test: `test_register_plugin_success()` - register and verify
- [ ] 8.7 Write test: `test_register_plugin_invalid_type()` - reject non-plugin
- [ ] 8.8 Write test: `test_get_plugin_success()` - retrieve registered plugin
- [ ] 8.9 Write test: `test_get_plugin_not_found()` - PluginNotFoundError raised
- [ ] 8.10 Write test: `test_list_registered_plugins()` - list all tool_types
- [ ] 8.11 Write test: `test_unregister_plugin()` - remove and verify
- [ ] 8.12 Run tests and verify all pass

### Task 9: Create Integration Tests (AC: #8)
- [ ] 9.1 Create `tests/integration/test_plugin_manager_integration.py` file
- [ ] 9.2 Create two mock plugins: MockServiceDeskPlugin, MockJiraPlugin
- [ ] 9.3 Write test: `test_register_and_retrieve_multiple_plugins()`
  - [ ] 9.3a Register MockServiceDeskPlugin with tool_type="servicedesk_plus"
  - [ ] 9.3b Register MockJiraPlugin with tool_type="jira"
  - [ ] 9.3c Retrieve both plugins by tool_type
  - [ ] 9.3d Verify correct plugin returned for each tool_type
  - [ ] 9.3e Call plugin methods to ensure they work
- [ ] 9.4 Write test: `test_plugin_discovery_auto_load()`
  - [ ] 9.4a Create temporary plugin directory structure
  - [ ] 9.4b Call discover_plugins()
  - [ ] 9.4c Verify plugins auto-registered
  - [ ] 9.4d Clean up temporary directories
- [ ] 9.5 Run integration tests and verify all pass

### Task 10: Add Logging and Error Handling (Meta)
- [ ] 10.1 Import Loguru logger
- [ ] 10.2 Log plugin registration at INFO level
- [ ] 10.3 Log plugin retrieval attempts at DEBUG level
- [ ] 10.4 Log discovery errors at WARNING level (failed imports)
- [ ] 10.5 Include plugin details in log messages (tool_type, class name)

### Task 11: Update Package Exports (Meta)
- [ ] 11.1 Edit `src/plugins/__init__.py` to export PluginManager
- [ ] 11.2 Export custom exceptions: PluginNotFoundError, PluginValidationError
- [ ] 11.3 Add to `__all__` list
- [ ] 11.4 Verify imports work: `from src.plugins import PluginManager`

### Task 12: Create Plugin Discovery Documentation
- [ ] 12.1 Update `docs/plugin-architecture.md` with Plugin Manager section
- [ ] 12.2 Document registration patterns (programmatic vs discovery)
- [ ] 12.3 Document directory structure conventions for auto-discovery
- [ ] 12.4 Add code examples for registering plugins
- [ ] 12.5 Document error handling patterns

### Task 13: Validate Mypy Type Checking (AC: #6)
- [ ] 13.1 Run `mypy src/plugins/registry.py` and verify no errors
- [ ] 13.2 Fix any type hint issues with dynamic loading
- [ ] 13.3 Test with mypy strict mode enabled
- [ ] 13.4 Document TYPE_CHECKING pattern in code comments

### Task 14: Code Quality and Standards (Meta)
- [ ] 14.1 Run Black formatter on all new Python files
- [ ] 14.2 Run Ruff linter and fix any issues
- [ ] 14.3 Verify Google-style docstrings for all public methods
- [ ] 14.4 Check file size: registry.py should be <500 lines (per CLAUDE.md)
- [ ] 14.5 Verify no security issues (bandit scan)

### Task 15: Integration with Application Startup (Planning)
- [ ] 15.1 Document where to call `load_plugins_on_startup()` (main.py or celery_app.py)
- [ ] 15.2 Ensure plugin manager initialized before processing webhooks
- [ ] 15.3 Add startup logging to confirm plugins loaded
- [ ] 15.4 Plan error handling if plugin discovery fails at startup
    </tasks>
  </story>

  <acceptanceCriteria>
1. PluginManager class created at `src/plugins/registry.py` with singleton pattern
2. Plugin registration method: `register_plugin(tool_type: str, plugin: TicketingToolPlugin)`
3. Plugin retrieval method: `get_plugin(tool_type: str) -> TicketingToolPlugin`
4. Plugin discovery on startup (auto-load from `src/plugins/*/` directories)
5. Error handling for missing plugins (raise PluginNotFoundError with clear message)
6. Plugin validation on registration (ensures implements all required methods)
7. Unit tests with mock plugins for registration and retrieval
8. Integration test: register 2 plugins, retrieve by tool_type
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/plugin-architecture.md</path>
        <title>Plugin Architecture Documentation</title>
        <section>Plugin Manager Design (lines 50-149)</section>
        <snippet>Comprehensive documentation of plugin architecture pattern including Plugin Manager singleton design, dynamic routing based on tenant tool_type, registry pattern with Dictionary storage, discovery conventions for auto-loading plugins from src/plugins/*/ directories, and type safety strategy using TYPE_CHECKING guards for mypy static analysis with runtime ABC validation.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic 7: Plugin Architecture &amp; Multi-Tool Support</title>
        <section>Story 7.2: Implement Plugin Manager and Registry (lines 1289-1320)</section>
        <snippet>Story definition for Plugin Manager implementation. Creates PluginManager class with singleton pattern at src/plugins/registry.py, implements register_plugin() and get_plugin() methods, plugin discovery on startup auto-loading from src/plugins/*/ directories, error handling with PluginNotFoundError, plugin validation ensuring all abstract methods implemented, unit tests with mock plugins, and integration test registering 2 plugins and retrieving by tool_type.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Epic 7 Plugin Architecture Mapping (lines 185-250)</section>
        <snippet>Architecture mapping for Epic 7 plugin system. Defines src/plugins/ structure with base interface, registry manager, and tool-specific implementations. ADR-010 establishes Abstract Base Class (ABC) plugin architecture for ticketing tool integrations with type safety via mypy and runtime validation via ABC enforcement.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>ADR-010: Plugin Architecture for Multi-Tool Support (lines 1217-1274)</section>
        <snippet>Architectural Decision Record for plugin architecture. Decision to implement ABC-based plugin system with Plugin Manager for dynamic routing. Two-phase rollout: MVP v2.0 (Epic 7.1-7.3) extracts ServiceDesk Plus to plugin and creates base class and manager, then (Epic 7.4-7.5) adds Jira Service Management as second implementation proving extensibility.</snippet>
      </doc>
      <doc>
        <path>docs/stories/7-1-design-and-implement-plugin-base-interface.md</path>
        <title>Story 7.1: Plugin Base Interface (COMPLETED)</title>
        <section>TicketingToolPlugin ABC and MockTicketingToolPlugin</section>
        <snippet>Completed Story 7.1 provides TicketingToolPlugin ABC at src/plugins/base.py with 4 abstract methods (validate_webhook, get_ticket, update_ticket, extract_metadata) and TicketMetadata dataclass. MockTicketingToolPlugin fixture available in tests/unit/test_plugin_base.py for testing Plugin Manager. All 27 tests passing, mypy validation clean (0 errors), comprehensive documentation (2,254 lines).</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/plugins/base.py</path>
        <kind>interface</kind>
        <symbol>TicketingToolPlugin</symbol>
        <lines>51-316</lines>
        <reason>Abstract base class that Plugin Manager will register and retrieve. All plugins must inherit from this ABC. Plugin Manager will validate plugins implement all 4 abstract methods (validate_webhook, get_ticket, update_ticket, extract_metadata) during registration using isinstance() and ABC enforcement.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/base.py</path>
        <kind>dataclass</kind>
        <symbol>TicketMetadata</symbol>
        <lines>18-48</lines>
        <reason>Standardized metadata structure returned by plugin.extract_metadata(). Used throughout enhancement workflow. Plugin Manager doesn't directly use this but plugins registered in manager will return this type.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/__init__.py</path>
        <kind>module</kind>
        <symbol>__all__</symbol>
        <lines>1-28</lines>
        <reason>Current plugin package exports. Must be updated to include PluginManager, PluginNotFoundError, and PluginValidationError after implementation (Task 11). Currently exports only TicketingToolPlugin and TicketMetadata from Story 7.1.</reason>
      </artifact>
      <artifact>
        <path>tests/unit/test_plugin_base.py</path>
        <kind>test fixture</kind>
        <symbol>MockTicketingToolPlugin</symbol>
        <lines>478-556</lines>
        <reason>Reusable mock plugin fixture from Story 7.1. Implements all 4 abstract methods with configurable responses. Can be used in Plugin Manager unit tests for registration and retrieval testing without creating new mock classes. Available as pytest fixture at lines 625-646.</reason>
      </artifact>
      <artifact>
        <path>tests/unit/test_plugin_base.py</path>
        <kind>test patterns</kind>
        <symbol>Test class structure</symbol>
        <lines>558-646</lines>
        <reason>Example test patterns from Story 7.1 showing pytest structure, fixtures, async test handling, and assertion patterns. Plugin Manager tests should follow same conventions: descriptive test names, comprehensive docstrings, separate test classes for different components.</reason>
      </artifact>
    </code>
    <dependencies>
      <python version="3.12">
        <package name="pytest" version=">=7.4.3">Unit testing framework</package>
        <package name="pytest-asyncio" version=">=0.21.1">Async test support for async plugin methods</package>
        <package name="pytest-mock" version=">=3.12.0">Mocking support for plugin testing</package>
        <package name="mypy" version=">=1.7.1">Static type checking with TYPE_CHECKING guards</package>
        <package name="loguru" version=">=0.7.2">Logging for plugin registration and discovery</package>
        <package name="pydantic" version=">=2.5.0">Already used for TicketMetadata validation</package>
      </python>
      <builtin>
        <module>importlib</module>
        <module>pathlib</module>
        <module>typing (TYPE_CHECKING, Dict, Type, Optional, List)</module>
        <module>abc (ABC, abstractmethod)</module>
      </builtin>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="C1" source="CLAUDE.md">
      <rule>File size limit: registry.py must be &lt;500 lines</rule>
      <rationale>Project standard for modularity. If exceeds, split into registry.py and discovery.py modules.</rationale>
    </constraint>
    <constraint id="C2" source="CLAUDE.md">
      <rule>Google-style docstrings required for all public methods</rule>
      <rationale>Project documentation standard. Include Args, Returns, Raises, Examples sections.</rationale>
    </constraint>
    <constraint id="C3" source="pyproject.toml">
      <rule>Mypy strict mode: disallow_untyped_defs = true</rule>
      <rationale>All functions must have complete type hints. Use TYPE_CHECKING guards for dynamic imports to satisfy mypy while enabling runtime loading.</rationale>
    </constraint>
    <constraint id="C4" source="Dev Notes">
      <rule>Singleton pattern for PluginManager (single instance application-wide)</rule>
      <rationale>Multiple instances would cause inconsistent plugin availability. Use __new__ method or class variable to enforce.</rationale>
    </constraint>
    <constraint id="C5" source="Story 7.1">
      <rule>No modifications to TicketingToolPlugin ABC interface</rule>
      <rationale>Story 7.1 interface is stable and complete. Plugin Manager must work with existing interface without changes.</rationale>
    </constraint>
    <constraint id="C6" source="Dev Notes">
      <rule>Plugin validation: isinstance(plugin, TicketingToolPlugin) + ABC method checking</rule>
      <rationale>Compile-time mypy validation + runtime ABC enforcement ensures plugins implement all required methods.</rationale>
    </constraint>
    <constraint id="C7" source="Dev Notes">
      <rule>Discovery convention: src/plugins/*/plugin.py structure</rule>
      <rationale>Standardized directory layout enables auto-discovery. Plugin class file must be named plugin.py.</rationale>
    </constraint>
    <constraint id="C8" source="Dev Notes">
      <rule>Non-fatal discovery failures: log warning and continue</rule>
      <rationale>One broken plugin should not prevent discovery of other valid plugins.</rationale>
    </constraint>
    <constraint id="C9" source="Testing Standards">
      <rule>Test coverage &gt;80% following Story 7.1 standard (27 tests, 100% coverage)</rule>
      <rationale>Maintain quality bar from Story 7.1. Include unit tests (11 tests) and integration tests (2 tests).</rationale>
    </constraint>
    <constraint id="C10" source="Architecture ADR-010">
      <rule>Plugin Manager routes by tenant tool_type, not hardcoded conditionals</rule>
      <rationale>Dynamic routing eliminates tight coupling. Query tenant_configs.tool_type, call manager.get_plugin(tool_type).</rationale>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>PluginManager.register_plugin</name>
      <kind>method</kind>
      <signature>register_plugin(tool_type: str, plugin: TicketingToolPlugin) -> None</signature>
      <path>src/plugins/registry.py (to be created)</path>
      <description>Registers a plugin instance for a specific tool_type. Validates plugin is instance of TicketingToolPlugin and all abstract methods implemented. Raises PluginValidationError if validation fails. Stores in internal _plugins dictionary.</description>
    </interface>
    <interface>
      <name>PluginManager.get_plugin</name>
      <kind>method</kind>
      <signature>get_plugin(tool_type: str) -> TicketingToolPlugin</signature>
      <path>src/plugins/registry.py (to be created)</path>
      <description>Retrieves registered plugin by tool_type. Returns plugin instance if found. Raises PluginNotFoundError with list of available plugins if tool_type not registered. Used by webhook endpoint and Celery workers to route requests.</description>
    </interface>
    <interface>
      <name>PluginManager.discover_plugins</name>
      <kind>method</kind>
      <signature>discover_plugins() -> None</signature>
      <path>src/plugins/registry.py (to be created)</path>
      <description>Scans src/plugins/*/ directories for plugin.py files. Uses importlib to dynamically import modules. Detects classes inheriting from TicketingToolPlugin. Instantiates and auto-registers discovered plugins. Logs warnings for failed imports but continues discovery.</description>
    </interface>
    <interface>
      <name>PluginManager.list_registered_plugins</name>
      <kind>method</kind>
      <signature>list_registered_plugins() -> List[str]</signature>
      <path>src/plugins/registry.py (to be created)</path>
      <description>Returns list of all registered tool_types. Used for debugging and error messages showing available plugins.</description>
    </interface>
    <interface>
      <name>TicketingToolPlugin (from Story 7.1)</name>
      <kind>abstract base class</kind>
      <signature>ABC with 4 abstract methods</signature>
      <path>src/plugins/base.py</path>
      <description>Base interface all plugins must implement. Plugin Manager validates plugins against this interface during registration. Methods: validate_webhook, get_ticket, update_ticket, extract_metadata. Full specification in src/plugins/base.py lines 51-316.</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
Project uses pytest with asyncio support for testing async plugin methods. Testing standards from Story 7.1 and project conventions:
- Test framework: pytest >=7.4.3 with pytest-asyncio for async tests
- Test structure: Separate test classes for each component (TestPluginManager, TestPluginDiscovery, etc.)
- Naming convention: test_*.py files, test_* functions, Test* classes
- Async handling: @pytest.mark.asyncio for async test functions, asyncio_mode = "auto"
- Fixtures: Reuse MockTicketingToolPlugin from tests/unit/test_plugin_base.py (lines 625-646)
- Docstrings: Comprehensive docstrings for all test functions explaining what is being tested
- Coverage target: &gt;80% (Story 7.1 achieved 100% with 27 tests)
- Type hints: All test functions should have type hints for parameters and returns
- Mypy validation: Tests must pass mypy strict mode checks
- Code quality: Black formatter (line-length=100), Ruff linter, no bandit security issues
    </standards>
    <locations>
tests/unit/test_plugin_registry.py (to be created) - Unit tests for PluginManager
tests/integration/test_plugin_manager_integration.py (to be created) - Integration tests for multi-plugin registration/retrieval
    </locations>
    <ideas>
      <test id="AC1" criteria="PluginManager singleton pattern">
        <name>test_plugin_manager_singleton</name>
        <description>Verify PluginManager returns same instance on multiple instantiations. Create two instances, assert they are the same object (id() comparison).</description>
      </test>
      <test id="AC2" criteria="Plugin registration">
        <name>test_register_plugin_success</name>
        <description>Register MockTicketingToolPlugin with tool_type="test_tool", verify it's stored in registry. Use list_registered_plugins() to confirm.</description>
      </test>
      <test id="AC2" criteria="Plugin registration validation">
        <name>test_register_plugin_invalid_type</name>
        <description>Attempt to register non-plugin object (e.g., dict), expect PluginValidationError. Verify error message mentions required interface.</description>
      </test>
      <test id="AC3" criteria="Plugin retrieval">
        <name>test_get_plugin_success</name>
        <description>Register plugin, then retrieve it by tool_type. Assert returned plugin is same instance as registered.</description>
      </test>
      <test id="AC5" criteria="Missing plugin error">
        <name>test_get_plugin_not_found</name>
        <description>Attempt to retrieve unregistered tool_type, expect PluginNotFoundError. Verify error message includes list of available plugins.</description>
      </test>
      <test id="AC4" criteria="Plugin discovery">
        <name>test_plugin_discovery_auto_load</name>
        <description>Create temporary plugin directory structure with mock plugin.py file. Call discover_plugins(), verify plugin auto-registered. Clean up temp directories.</description>
      </test>
      <test id="AC7" criteria="Helper methods">
        <name>test_list_registered_plugins</name>
        <description>Register 3 plugins with different tool_types. Call list_registered_plugins(), verify all 3 tool_types returned.</description>
      </test>
      <test id="AC7" criteria="Helper methods">
        <name>test_unregister_plugin</name>
        <description>Register plugin, unregister it, verify no longer in registry. Attempt get_plugin(), expect PluginNotFoundError.</description>
      </test>
      <test id="AC8" criteria="Multiple plugin integration">
        <name>test_register_and_retrieve_multiple_plugins (integration)</name>
        <description>Register MockServiceDeskPlugin and MockJiraPlugin with different tool_types. Retrieve both by tool_type. Call plugin methods to verify correct plugin returned. Verify plugins isolated (changes to one don't affect other).</description>
      </test>
      <test id="AC6" criteria="Plugin validation on registration">
        <name>test_register_plugin_validates_abstract_methods</name>
        <description>Create incomplete plugin class missing abstract method implementations. Attempt registration, expect PluginValidationError or TypeError from ABC.</description>
      </test>
      <test id="discovery_errors" criteria="Discovery error handling">
        <name>test_discovery_handles_import_errors</name>
        <description>Create temp directory with invalid plugin.py (syntax error). Call discover_plugins(), verify warning logged but no exception raised. Verify other valid plugins still discovered.</description>
      </test>
    </ideas>
  </tests>
</story-context>
