<?xml version="1.0" encoding="UTF-8"?>
<story-context id="bmad/bmm/workflows/4-implementation/story-context" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>6</storyId>
    <title>Implement Documentation and Knowledge Base Search</title>
    <status>drafted</status>
    <generatedAt>2025-11-02T12:00:00Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/2-6-implement-documentation-and-knowledge-base-search.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>enhancement agent</asA>
    <iWant>search knowledge base articles and documentation</iWant>
    <soThat>technicians receive relevant troubleshooting guides</soThat>
    <tasks>
      <task id="1">Design KB search service interface with function signature, return type documentation, and KB API assumptions</task>
      <task id="2">Implement KB API client with async HTTP calls using httpx, configuration loading from tenant_configs, and response parsing</task>
      <task id="3">Implement Redis caching for KB results with 1-hour TTL and cache-before-API pattern</task>
      <task id="4">Implement error handling and graceful degradation for timeouts, HTTP errors, and Redis failures</task>
      <task id="5">Create comprehensive unit tests covering success paths, timeouts, errors, cache hits/misses, and tenant isolation</task>
      <task id="6">Integrate KB search with enhancement workflow, reviewing LangGraph structure and Story 2.8 integration points</task>
      <task id="7">Create integration tests with mock KB API server, cache persistence, and multi-tenant scenarios</task>
      <task id="8">Verify error handling and structured logging with correlation_id and tenant_id</task>
      <task id="9">Document KB API contract, configuration requirements, and tenant configuration setup</task>
      <task id="10">Set up performance monitoring with response time logging and cache hit/miss ratio tracking</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Function created to search documentation table/external KB API for articles matching ticket keywords</criterion>
    <criterion id="2">Search uses keywords extracted from ticket description (implementation-agnostic extraction)</criterion>
    <criterion id="3">Returns top 3 relevant articles with: title, summary, URL</criterion>
    <criterion id="4">Handles KB API unavailability gracefully (returns empty list, logs warning)</criterion>
    <criterion id="5">Results cached in Redis for 1 hour (3600 seconds TTL) to reduce redundant API calls</criterion>
    <criterion id="6">API timeout set to 10 seconds; partial caching tolerates timeout gracefully</criterion>
    <criterion id="7">Unit tests with mocked KB API responses covering success, timeout, and error cases</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-2.md</path>
        <title>Technical Specification for Epic 2</title>
        <section>4. Context Gathering: Knowledge Base Search (Story 2.6)</section>
        <snippet>Integrate with knowledge base API to retrieve relevant articles, with Redis caching. Cache Key pattern: kb_search:{tenant_id}:{hash(description)}, TTL: 1 hour. Error Handling: Timeout 10 seconds, return empty list, log warning (graceful degradation).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Epic 2: Enhancement Pipeline Architecture</section>
        <snippet>Knowledge base search is the second context gathering source (after ticket history) in the enhancement workflow. Integrated into LangGraph workflow (Story 2.8) as parallel context gathering node alongside IP address lookup.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Functional Requirements: FR006 Knowledge Base Integration, FR008 Gathering monitoring data</section>
        <snippet>System integrates with external knowledge base to surface relevant troubleshooting guides and articles. Search results enhance ticket context for AI-powered enhancement suggestions.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/cache/redis_client.py</path>
        <kind>cache-client</kind>
        <symbol>redis_client</symbol>
        <lines>1-50</lines>
        <reason>Redis client initialization and async methods (get, setex) required for KB search caching layer. Story 1.4 established Redis infrastructure that Story 2.6 extends with KB-specific cache keys.</reason>
      </artifact>
      <artifact>
        <path>src/services/ticket_search_service.py</path>
        <kind>service</kind>
        <symbol>search_ticket_history</symbol>
        <lines>1-100</lines>
        <reason>Example of async service pattern for external API integration with error handling and structured logging. Story 2.5 pattern to replicate for KB search service. Demonstrates tenant isolation and graceful degradation patterns.</reason>
      </artifact>
      <artifact>
        <path>src/config.py</path>
        <kind>configuration</kind>
        <symbol>settings</symbol>
        <lines>1-50</lines>
        <reason>Configuration management for environment variables, API keys, and timeouts. KB search will load KB API base URL and API key from configuration (tenant-specific from tenant_configs table).</reason>
      </artifact>
      <artifact>
        <path>src/utils/logger.py</path>
        <kind>utility</kind>
        <symbol>get_logger, structured_logging</symbol>
        <lines>1-80</lines>
        <reason>Structured logging with correlation_id and tenant_id fields. Required for monitoring KB search latency, cache hits/misses, and error tracking per tenant.</reason>
      </artifact>
      <artifact>
        <path>src/database/models.py</path>
        <kind>model</kind>
        <symbol>TenantConfig</symbol>
        <lines>100-150</lines>
        <reason>TenantConfig table stores KB API credentials (base URL, API key) per tenant. KB search will query this table to load tenant-specific KB configuration at runtime.</reason>
      </artifact>
      <artifact>
        <path>src/workers/tasks.py</path>
        <kind>task</kind>
        <symbol>enhance_ticket</symbol>
        <lines>50-150</lines>
        <reason>enhance_ticket task (Story 2.4) calls KB search as part of context gathering. Story 2.6 implementation will integrate with this existing task to provide KB articles to the enhancement pipeline.</reason>
      </artifact>
    </code>
    <dependencies>
      <dependency>
        <ecosystem>python</ecosystem>
        <package>httpx</package>
        <version>>=0.24.0</version>
        <reason>Async HTTP client for external KB API calls with timeout support and request/response handling.</reason>
      </dependency>
      <dependency>
        <ecosystem>python</ecosystem>
        <package>redis</package>
        <version>>=4.0.0</version>
        <reason>Redis client for caching KB search results with TTL support (already in use via src/cache/redis_client.py).</reason>
      </dependency>
      <dependency>
        <ecosystem>python</ecosystem>
        <package>pydantic</package>
        <version>>=2.0.0</version>
        <reason>Data validation for KB API responses and configuration models. Ensures consistent article structure across API providers.</reason>
      </dependency>
      <dependency>
        <ecosystem>python</ecosystem>
        <package>pytest</package>
        <version>>=7.0.0</version>
        <reason>Testing framework for unit and integration tests. pytest-asyncio for async test execution.</reason>
      </dependency>
      <dependency>
        <ecosystem>python</ecosystem>
        <package>pytest-asyncio</package>
        <version>>=0.21.0</version>
        <reason>Pytest plugin for async test support. Required for testing async search_knowledge_base function.</reason>
      </dependency>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="1">
      <name>Timeout Enforcement</name>
      <description>KB API calls must timeout after 10 seconds. Enforced via httpx.AsyncClient(timeout=10.0). Timeout must return empty list, not propagate exception to caller.</description>
      <source>AC #6, tech-spec-epic-2.md Section 4</source>
    </constraint>
    <constraint id="2">
      <name>Graceful Degradation</name>
      <description>All error paths (timeout, API failure, Redis failure) must return empty list and log appropriately. No exceptions propagated to caller. System must continue operation if KB API unavailable.</description>
      <source>AC #4, NFR003 (Resilience)</source>
    </constraint>
    <constraint id="3">
      <name>Tenant Isolation</name>
      <description>Cache keys and all queries must include tenant_id. Different tenants cannot share cached KB results. KB API credentials loaded per-tenant from tenant_configs table.</description>
      <source>Story 2.6 Dev Notes, Architecture: Multi-Tenant Design</source>
    </constraint>
    <constraint id="4">
      <name>Caching Strategy</name>
      <description>Results cached in Redis with 1-hour (3600 seconds) TTL. Cache key pattern: kb_search:{tenant_id}:{hash(description)}. Cache checked before API call; on miss, result cached after successful API response.</description>
      <source>AC #5, tech-spec-epic-2.md Section 4</source>
    </constraint>
    <constraint id="5">
      <name>Async Pattern</name>
      <description>Must use async/await for I/O-bound operations (API calls, Redis operations). Function signature: async def search_knowledge_base(...). Consistent with Story 2.5 patterns and codebase conventions.</description>
      <source>Story 2.6 Dev Notes: Async function patterns</source>
    </constraint>
    <constraint id="6">
      <name>Return Type</name>
      <description>Always return List[Dict] with keys: title, summary, url. On success, return up to 3 articles. On error/timeout, return empty list []. Never return None or raise exceptions.</description>
      <source>AC #3, tech-spec-epic-2.md</source>
    </constraint>
    <constraint id="7">
      <name>Structured Logging</name>
      <description>All log messages include: tenant_id, correlation_id, operation name, relevant metrics (latency_ms, cache_hit). No sensitive data (API keys, full URLs) in logs. Use logger.info(), .warning(), .error() appropriately.</description>
      <source>Story 2.6 Dev Notes: Error handling and logging verification</source>
    </constraint>
    <constraint id="8">
      <name>Layer Architecture</name>
      <description>KB search implementation belongs in src/services/kb_search.py (service layer). Tests in tests/unit/test_kb_search.py and tests/integration/test_kb_search_integration.py. Mirrors existing service structure (ticket_search_service.py, ticket_storage_service.py).</description>
      <source>Story 2.6 Dev Notes: Project Structure Notes</source>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>search_knowledge_base</name>
      <kind>async-function</kind>
      <signature>async def search_knowledge_base(tenant_id: str, description: str, kb_base_url: str, kb_api_key: str, limit: int = 3) -> List[Dict]:</signature>
      <path>src/services/kb_search.py</path>
      <description>Primary function to search knowledge base for articles matching ticket description. Returns list of top 3 articles with title, summary, URL. Handles caching, timeouts, and errors gracefully.</description>
      <notes>All parameters come from tenant_configs table except description (from ticket). Limit defaults to 3 per AC #3. Raises no exceptions; all errors handled internally with empty list return.</notes>
    </interface>
    <interface>
      <name>KB API Contract</name>
      <kind>REST-endpoint</kind>
      <signature>GET {kb_base_url}/api/search?query={description}&amp;limit={limit}</signature>
      <path>External KB API (tenant-specific)</path>
      <description>External knowledge base API endpoint. Expected response format: JSON with "results" array containing objects with "title", "summary", "url" fields. Auth via Bearer token in Authorization header.</description>
      <notes>Response timeout: 10 seconds. If KB API changes response format or endpoint, modify parsing in kb_search.py. Summary field truncated to 200 characters per AC.</notes>
    </interface>
    <interface>
      <name>Redis Cache Interface</name>
      <kind>cache-client</kind>
      <signature>redis_client.get(key) -> Optional[str], redis_client.setex(key, ttl, value) -> None</signature>
      <path>src/cache/redis_client.py</path>
      <description>Redis async client for caching KB results. get() returns cached JSON string or None. setex() stores result with 3600-second TTL.</description>
      <notes>Cache errors (connection failure) logged but not propagated; graceful fallback to API call without caching.</notes>
    </interface>
    <interface>
      <name>TenantConfig Table</name>
      <kind>database-table</kind>
      <signature>SELECT kb_api_base_url, kb_api_key FROM tenant_configs WHERE tenant_id = ?</signature>
      <path>src/database/models.py (TenantConfig table)</path>
      <description>Database table storing tenant-specific KB API configuration. Query via async session to load KB credentials at runtime.</description>
      <notes>Assumes TenantConfig model has kb_api_base_url and kb_api_key fields. If field names differ, update kb_search.py to match actual column names.</notes>
    </interface>
  </interfaces>

  <tests>
    <standards>
      <paragraph>
        Story 2.6 uses pytest-asyncio for async testing. Test framework established in Story 1.1 extends to this story. Tests use unittest.mock to mock httpx.AsyncClient and redis_client. Integration tests use test Redis instance (configured via pytest fixtures). Mock KB API server created using responses library or custom mock class. All tests follow existing test structure in tests/unit/ and tests/integration/ directories. Tests verify AC compliance, error handling, tenant isolation, and cache behavior.
      </paragraph>
    </standards>
    <locations>
      <location>tests/unit/test_kb_search.py</location>
      <location>tests/integration/test_kb_search_integration.py</location>
      <location>tests/fixtures/kb_api_mock.py (optional shared fixtures)</location>
    </locations>
    <ideas>
      <idea id="1" ac="1,3">Test: Valid KB API response → Returns 3 articles with title, summary, url. Verify correct API parameters passed (query, limit). Mock httpx.AsyncClient.get() to return 200 with article payload.</idea>
      <idea id="2" ac="4">Test: KB API timeout (10s) → Returns empty list, logs warning. Mock httpx.AsyncClient.get() to raise httpx.TimeoutException. Verify no exception propagates to caller.</idea>
      <idea id="3" ac="4">Test: KB API error (500) → Returns empty list, logs error. Mock httpx.AsyncClient.get() to return 500 status. Verify graceful handling.</idea>
      <idea id="4" ac="5">Test: Cache hit → Returns cached results without calling API. Mock redis_client.get() to return JSON string. Verify httpx.AsyncClient.get() NOT called.</idea>
      <idea id="5" ac="5">Test: Cache miss → Calls API and caches result. Mock redis_client.get() to return None, then API returns articles. Verify redis_client.setex() called with 3600 TTL.</idea>
      <idea id="6" ac="2">Test: Tenant isolation → Cache keys include tenant_id. Different tenants don't share cache. Verify kb_search:tenant_a:hash1 ≠ kb_search:tenant_b:hash1.</idea>
      <idea id="7" ac="4">Test: Redis unavailable → Falls back to API call. Mock redis_client.get() to raise RedisError. Verify API called despite Redis failure, warning logged.</idea>
      <idea id="8" ac="7">Integration: End-to-end KB search with mock API server and test Redis instance. Query "database connectivity" → Returns articles from mock API.</idea>
      <idea id="9" ac="5">Integration: Cache persistence across calls. First search → API called. Second search (same query) → Cache hit, no API call.</idea>
      <idea id="10" ac="5,6">Integration: Concurrent requests for same query. 5 concurrent searches → Only 1 KB API call, 4 cache hits.</idea>
    </ideas>
  </tests>
</story-context>
