<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>7</epicId>
    <storyId>8</storyId>
    <title>Create Plugin Management UI</title>
    <status>drafted</status>
    <generatedAt>2025-11-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/7-8-create-plugin-management-ui.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system administrator</asA>
    <iWant>a plugin management interface in the Streamlit admin UI</iWant>
    <soThat>I can install, configure, and assign plugins to tenants without database access</soThat>
    <tasks>
### Task 1: Create Plugin Registry API Endpoint (AC: #1)
- Create src/api/plugins.py module
- Implement GET /api/plugins endpoint returning all registered plugins
- Add error handling for plugin registry access failures
- Register endpoint in src/main.py APIRouter

### Task 2: Create Plugin Details API Endpoint (AC: #2)
- Implement GET /api/plugins/{plugin_id} endpoint
- Return full plugin configuration schema (JSON Schema format)
- Add 404 error handling for non-existent plugin_id
- Add schema validation for plugin configuration fields

### Task 3: Create Streamlit Plugin Management Page (AC: #3, #4)
- Create src/admin/pages/03_Plugin_Management.py
- Fetch installed plugins from GET /api/plugins endpoint
- Display plugins in st.dataframe with columns (name, type, version, status, description)
- Add search/filter controls and expandable configuration views

### Task 4: Implement Plugin Configuration Form (AC: #5)
- Create reusable component: src/admin/components/plugin_config_form.py
- Implement dynamic form field generator based on plugin schema
- Add form validation before submission with inline error display

### Task 5: Implement Connection Testing Feature (AC: #6)
- Add POST /api/plugins/{plugin_id}/test endpoint
- Add test_connection() abstract method to TicketingToolPlugin ABC
- Implement test_connection() in ServiceDesk Plus and Jira plugins
- Add "Test Connection" button in plugin config form with result display

### Task 6: Integrate Tenant-Plugin Assignment (AC: #7)
- Update src/admin/pages/02_Tenant_Management.py to add plugin assignment
- Add "Assigned Plugin" column to tenant table
- Add plugin selector dropdown in tenant create/edit forms
- Add validation and reassignment capability with confirmation

### Task 7: Implement Audit Logging (AC: #8)
- Import audit_log service from src/services/audit_log_service.py
- Log plugin configuration changes, connection tests, and tenant-plugin assignments
- Capture user/session information for audit trail

### Task 8: Create Plugin Administration Documentation (AC: #9)
- Create docs/plugins/plugin-administration-guide.md
- Write sections: Overview, Viewing Plugins, Configuring, Assigning to Tenants, Troubleshooting
- Follow Diátaxis "How-To" framework
- Ensure file size ≤500 lines

### Task 9: Write Unit Tests
- Create tests/unit/test_plugins_api.py (6+ tests)
- Create tests/unit/test_plugin_config_form.py (4+ tests)
- Verify minimum 15 unit tests total

### Task 10: Write Integration Tests
- Create tests/integration/test_plugin_management_ui.py
- Test full workflows: plugin config, tenant assignment, audit logging
- Verify minimum 5 integration tests

### Task 11: Run All Tests and Validate
- Run unit and integration tests
- Run mypy validation in strict mode
- Run Bandit security scan
- Verify code coverage ≥80%
    </tasks>
  </story>

  <acceptanceCriteria>
1. Plugin registry API endpoint created: GET /api/plugins (returns list of registered plugins with metadata)
2. Plugin details API endpoint created: GET /api/plugins/{plugin_id} (returns full plugin configuration schema)
3. Streamlit page created at src/admin/pages/03_Plugin_Management.py
4. UI displays all installed plugins in table format (name, type, version, status, description)
5. Plugin configuration form implemented with dynamic field generation based on plugin schema
6. Connection testing feature: "Test Connection" button validates plugin credentials before saving
7. Tenant-plugin assignment interface integrated with existing tenant management (Story 6.3)
8. All plugin management operations logged to audit_log table (who, what, when)
9. Documentation created: docs/plugins/plugin-administration-guide.md with admin workflows
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/plugins/plugin-architecture-overview.md</path>
        <title>Plugin Architecture Overview</title>
        <section>Overview</section>
        <snippet>Plugin architecture enables extensibility, separation of concerns, testability, and vendor flexibility. Each plugin implements TicketingToolPlugin ABC handling webhook validation, ticket retrieval, updates, and metadata extraction.</snippet>
      </doc>
      <doc>
        <path>docs/plugins/plugin-manager-guide.md</path>
        <title>Plugin Manager Guide</title>
        <section>Overview</section>
        <snippet>PluginManager provides centralized registration, validation, and retrieval of ticketing tool plugins using singleton pattern. Located at src/plugins/registry.py, implements auto-discovery and type-safe plugin retrieval by tool_type.</snippet>
      </doc>
      <doc>
        <path>docs/admin-ui-guide.md</path>
        <title>Admin UI Guide</title>
        <section>Overview, Features</section>
        <snippet>Streamlit 1.44+ web-based interface for managing multi-tenant platform. Provides real-time monitoring, tenant management, enhancement history, system operations, metrics, and worker monitoring without kubectl access.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>Admin UI Framework, Technology Stack</section>
        <snippet>Streamlit 1.30+ chosen for Epic 6 admin UI. Python-native, rapid prototyping, built-in components, beginner-friendly. FastAPI for REST endpoints, Pydantic for validation, SQLAlchemy 2.0+ async ORM.</snippet>
      </doc>
      <doc>
        <path>docs/database-schema.md</path>
        <title>Database Schema Documentation</title>
        <section>tenant_configs table</section>
        <snippet>Multi-tool support via tool_type column (servicedesk_plus, jira, zendesk). Tool-specific fields: servicedesk_url, jira_url, jira_project_key. enhancement_preferences JSONB stores tool-specific config. RLS enforces multi-tenancy isolation.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic 7.8 Details</title>
        <section>Story 7.8: Create Plugin Management UI</section>
        <snippet>System administrator needs plugin management interface in Streamlit admin UI to install, configure, and assign plugins to tenants without database access. Prerequisites: Stories 7.1-7.7 (plugin architecture complete), Story 6.3 (tenant management UI).</snippet>
      </doc>
      <doc>
        <path>docs/plugins/plugin-interface-reference.md</path>
        <title>Plugin Interface Reference</title>
        <section>TicketingToolPlugin ABC</section>
        <snippet>Defines abstract methods: validate_webhook_signature(), get_ticket_details(), update_ticket(), extract_ticket_metadata(). All plugins must implement this interface.</snippet>
      </doc>
      <doc>
        <path>docs/plugins/plugin-testing-guide.md</path>
        <title>Plugin Testing Guide</title>
        <section>Test Strategy</section>
        <snippet>Minimum 15 unit tests, 5 integration tests, 80% code coverage required. MockTicketingToolPlugin at tests/mocks/mock_plugin.py for testing.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/plugins/registry.py</path>
        <kind>service</kind>
        <symbol>PluginManager</symbol>
        <lines>86-369</lines>
        <reason>Singleton registry providing get_plugin(), list_registered_plugins(), is_plugin_registered() methods. Core API for retrieving plugin metadata and instances needed for GET /api/plugins endpoint.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/base.py</path>
        <kind>interface</kind>
        <symbol>TicketingToolPlugin</symbol>
        <lines>51-316</lines>
        <reason>ABC defining plugin interface with 4 abstract methods (validate_webhook, get_ticket, update_ticket, extract_metadata). Story must ADD test_connection() abstract method per Task 5.2.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/servicedesk_plus/plugin.py</path>
        <kind>plugin</kind>
        <symbol>ServiceDeskPlusPlugin</symbol>
        <lines>1-100</lines>
        <reason>Reference implementation showing plugin structure. Must implement test_connection() method per Task 5.3 to validate ServiceDesk Plus API connectivity.</reason>
      </artifact>
      <artifact>
        <path>src/admin/pages/2_Tenants.py</path>
        <kind>streamlit_page</kind>
        <symbol>add_tenant_dialog</symbol>
        <lines>39-100</lines>
        <reason>Existing tenant management UI showing dialog pattern, form validation, and ServiceDesk connection testing. Must integrate plugin assignment dropdown per Task 6.1.</reason>
      </artifact>
      <artifact>
        <path>src/api/feedback.py</path>
        <kind>api</kind>
        <symbol>submit_feedback</symbol>
        <lines>30-80</lines>
        <reason>Reference API endpoint showing FastAPI patterns: router setup, Pydantic schemas, async/await, error handling. Use as template for plugin endpoints.</reason>
      </artifact>
      <artifact>
        <path>src/database/models.py</path>
        <kind>model</kind>
        <symbol>AuditLog</symbol>
        <lines>482-497</lines>
        <reason>Audit logging table structure (id, timestamp, user, operation, details JSON, status). Use for Task 7 audit logging of plugin operations.</reason>
      </artifact>
      <artifact>
        <path>src/admin/pages/1_Dashboard.py</path>
        <kind>streamlit_page</kind>
        <symbol>N/A</symbol>
        <lines>N/A</lines>
        <reason>Existing admin page showing Streamlit patterns (st.dataframe, st.expander, st.form). Reference for 03_Plugin_Management.py page structure.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="fastapi" version=">=0.104.0">FastAPI web framework for REST endpoints</package>
        <package name="pydantic" version=">=2.5.0">Data validation and schema generation</package>
        <package name="streamlit" version=">=1.44.0">Admin UI framework</package>
        <package name="sqlalchemy" version=">=2.0.23">Async ORM for database operations</package>
        <package name="pandas" version=">=2.1.0">Data manipulation for Streamlit tables</package>
        <package name="plotly" version=">=5.18.0">Interactive visualizations</package>
        <package name="httpx" version=">=0.25.2">Async HTTP client for plugin API calls</package>
        <package name="cryptography" version=">=43.0.0">Fernet encryption for secrets</package>
        <package name="pytest" version=">=7.4.3">Testing framework</package>
        <package name="mypy" version=">=1.7.1">Static type checking</package>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
1. **File Size Limit**: All files must be ≤500 lines (from Story 7.7 learnings). Split into modules if needed.
2. **Type Safety**: Use mypy strict mode with type hints on all functions (from architecture.md).
3. **Testing Requirements**: Minimum 15 unit tests, 5 integration tests, 80% code coverage (from plugin-testing-guide.md).
4. **Diátaxis Framework**: Documentation must follow How-To structure (from Story 7.7).
5. **API Patterns**: Follow existing FastAPI patterns in src/api/feedback.py (router, Pydantic schemas, async/await).
6. **Streamlit Patterns**: Use st.dataframe, st.expander, st.form, st.fragment, caching (from Epic 6 stories).
7. **Security**: All plugin operations must log to AuditLog table (AC #8, Epic 3 requirement).
8. **Multi-Tool Support**: Plugin assignment must use tool_type field, not hardcode ServiceDesk Plus (from database-schema.md).
9. **Test Connection**: MUST add test_connection() abstract method to TicketingToolPlugin ABC (Task 5.2).
10. **Tenant Integration**: Plugin assignment integrates with existing 2_Tenants.py, not separate page (AC #7).
  </constraints>
  <interfaces>
    <interface>
      <name>PluginManager API</name>
      <kind>Python Class Methods</kind>
      <signature>
        get_plugin(tool_type: str) -> TicketingToolPlugin
        list_registered_plugins() -> List[str]
        is_plugin_registered(tool_type: str) -> bool
      </signature>
      <path>src/plugins/registry.py:86-369</path>
    </interface>
    <interface>
      <name>GET /api/plugins</name>
      <kind>REST endpoint</kind>
      <signature>Returns: List[PluginMetadata] with name, type, version, status, description</signature>
      <path>src/api/plugins.py (to be created)</path>
    </interface>
    <interface>
      <name>GET /api/plugins/{plugin_id}</name>
      <kind>REST endpoint</kind>
      <signature>Returns: PluginDetailsResponse with configuration schema (JSON Schema format)</signature>
      <path>src/api/plugins.py (to be created)</path>
    </interface>
    <interface>
      <name>POST /api/plugins/{plugin_id}/test</name>
      <kind>REST endpoint</kind>
      <signature>Request: PluginConfigRequest, Returns: ConnectionTestResponse with success/failure</signature>
      <path>src/api/plugins.py (to be created)</path>
    </interface>
    <interface>
      <name>test_connection()</name>
      <kind>Abstract method to add</kind>
      <signature>async def test_connection(self, config: Dict[str, Any]) -> Tuple[bool, str]</signature>
      <path>src/plugins/base.py:TicketingToolPlugin (to be added)</path>
    </interface>
    <interface>
      <name>AuditLog.create()</name>
      <kind>Database model</kind>
      <signature>id: UUID, timestamp: datetime, user: str, operation: str, details: JSON, status: str</signature>
      <path>src/database/models.py:482-497</path>
    </interface>
  </interfaces>
  <tests>
    <standards>
**Testing Framework:** Pytest 7.4.3+ with pytest-asyncio for async tests, pytest-mock for mocking, pytest-httpx for HTTP client testing.

**Requirements:**
- Minimum 15 unit tests across all modules
- Minimum 5 integration tests for end-to-end workflows
- 80%+ code coverage
- Mypy strict mode validation (zero type errors)
- Bandit security scanning (zero HIGH/MEDIUM issues)

**Test Patterns:**
- Use fixtures for common setup (plugin instances, mock configs, test data)
- Async tests with @pytest.mark.asyncio decorator
- Mock external dependencies (database, HTTP clients, PluginManager)
- Use MagicMock for synchronous mocks, AsyncMock for async functions
- Test success cases, edge cases, and failure cases for each function
- Validate Pydantic schema enforcement in API endpoints

**Naming Conventions:**
- Unit tests: tests/unit/test_{module_name}.py
- Integration tests: tests/integration/test_{feature}_integration.py
- Test functions: test_{function_name}_{scenario}
- Fixtures: {resource_name}_fixture or mock_{component}

**Test Markers:**
- @pytest.mark.unit for isolated unit tests
- @pytest.mark.integration for integration tests with real dependencies
- @pytest.mark.asyncio for async test functions
    </standards>
    <locations>
- tests/unit/test_plugins_api.py (API endpoint unit tests)
- tests/unit/test_plugin_config_form.py (Streamlit form component tests)
- tests/integration/test_plugin_management_ui.py (End-to-end UI workflow tests)
- tests/mocks/mock_plugin.py (Existing mock plugin for testing - Story 7.6)
- tests/conftest.py (Shared fixtures: test_db, test_redis, mock_plugin_manager)
    </locations>
    <ideas>
**AC1: GET /api/plugins endpoint**
- Unit: Test returns all registered plugins (2 plugins registered → 2 returned)
- Unit: Test returns empty list when no plugins registered
- Unit: Test plugin metadata structure (name, type, version, status, description)
- Unit: Test PluginManager.list_registered_plugins() integration

**AC2: GET /api/plugins/{plugin_id} endpoint**
- Unit: Test returns plugin details for valid plugin_id
- Unit: Test 404 error for non-existent plugin_id
- Unit: Test configuration schema format (JSON Schema with fields, types, validation rules)
- Unit: Test schema includes all plugin configuration fields

**AC3 & AC4: Streamlit Plugin Management Page**
- Unit: Test page renders without errors
- Unit: Test plugin data fetching from API
- Unit: Test dataframe column structure (name, type, version, status, description)
- Unit: Test search/filter controls functionality

**AC5: Plugin Configuration Form**
- Unit: Test dynamic form field generation from schema (string → text_input, boolean → checkbox)
- Unit: Test form validation (required fields, regex patterns, min/max length)
- Unit: Test form submission with valid data
- Unit: Test form submission with invalid data (displays error messages)

**AC6: Connection Testing Feature**
- Unit: Test POST /api/plugins/{plugin_id}/test endpoint with valid config → success
- Unit: Test POST /api/plugins/{plugin_id}/test with invalid config → failure
- Unit: Test timeout handling (30 second limit)
- Unit: Test test_connection() method added to TicketingToolPlugin ABC
- Integration: Test connection test for ServiceDesk Plus plugin (real API call to test instance)

**AC7: Tenant-Plugin Assignment**
- Unit: Test tenant table displays assigned plugin column
- Unit: Test plugin selector dropdown populated from registered plugins
- Unit: Test tenant update with plugin assignment saves to database
- Integration: Test full assignment workflow (create tenant → assign plugin → verify in DB)

**AC8: Audit Logging**
- Unit: Test plugin config update creates audit log entry
- Unit: Test connection test creates audit log entry
- Unit: Test tenant-plugin assignment creates audit log entry
- Integration: Test audit log entries include correct user, operation, details, timestamp

**AC9: Documentation**
- Unit: Test documentation file exists at docs/plugins/plugin-administration-guide.md
- Unit: Test documentation has required sections (Overview, Viewing, Configuring, Assigning, Troubleshooting)
- Unit: Test documentation follows Diátaxis How-To structure
- Unit: Test documentation file size ≤500 lines

**Integration Tests (5 required):**
1. Full workflow: View plugins → Configure plugin → Test connection → Save
2. Tenant-plugin assignment: Create tenant → Assign plugin → Verify in database
3. Audit logging: Perform operation → Verify audit_log entry created with correct fields
4. Plugin reassignment: Update tenant plugin → Verify changes persist
5. Error handling: Assign non-existent plugin → Verify error message displayed
    </ideas>
  </tests>
</story-context>
