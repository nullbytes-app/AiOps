<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>7</epicId>
    <storyId>6</storyId>
    <title>Create Plugin Testing Framework and Mock Plugins</title>
    <status>drafted</status>
    <generatedAt>2025-11-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/7-6-create-plugin-testing-framework-and-mock-plugins.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>a testing framework for plugins with configurable mock implementations</iWant>
    <soThat>I can test enhancement workflows without real ticketing tool dependencies and isolate plugin-specific logic from integration concerns</soThat>
    <tasks>
### Task 1: Create MockTicketingToolPlugin Base Implementation (AC: #1, #2)
- Implement MockTicketingToolPlugin class at tests/mocks/mock_plugin.py with configurable behaviors
- Support success scenarios, failure modes (API errors, auth errors, timeouts), edge cases
- Implement all four abstract methods: validate_webhook, extract_metadata, get_ticket, update_ticket
- Add call tracking for test assertions
- Add convenience factory methods (success_mode, api_error_mode, auth_error_mode, timeout_mode, not_found_mode)

### Task 2: Create Plugin Test Fixtures in conftest.py (AC: #3)
- Add mock_generic_plugin fixture (function scope for test isolation)
- Add mock_servicedesk_plugin fixture with ServiceDesk Plus-specific defaults
- Add mock_jira_plugin fixture with Jira-specific defaults
- Add mock_plugin_manager fixture for plugin routing tests
- Add parameterized fixture for testing multiple failure modes

### Task 3: Create Plugin Test Utilities Module (AC: #4)
- Create tests/utils/plugin_test_helpers.py with assertion utilities
- Implement assert_plugin_called, assert_plugin_called_with functions
- Add response capture utilities (capture_plugin_response)
- Add failure simulation utilities (configure_plugin_failure)
- Add TicketMetadata validation utilities (assert_ticket_metadata_valid)
- Add payload builder utilities (build_servicedesk_payload, build_jira_payload, build_generic_payload)

### Task 4: Create Integration Test with Mock Plugin (AC: #5)
- Create tests/integration/test_mock_plugin_workflow.py
- Test full enhancement workflow: webhook validation → metadata extraction → context gathering → ticket update
- Test success path with mock plugin
- Test failure modes: API error during get_ticket, timeout during update_ticket, ticket not found
- Demonstrate end-to-end mock usage

### Task 5: Create Plugin Testing Documentation (AC: #6)
- Create tests/README-plugins.md with comprehensive testing guide
- Document MockTicketingToolPlugin usage with examples
- Document all test fixtures and utilities
- Include best practices for plugin development testing
- Add troubleshooting section and references

### Task 6: Update CI Pipeline for Plugin Tests (AC: #7)
- Update .github/workflows/ to run plugin tests in isolation
- Separate unit tests, integration tests, and mock-based tests
- Add pytest markers (unit, integration, plugin)
- Configure test execution with clear separation

### Task 7: Create Unit Tests for MockTicketingToolPlugin (Meta)
- Test all factory methods (success_mode, api_error_mode, timeout_mode, etc.)
- Test call tracking functionality
- Test custom configuration
- Minimum 6 tests expected

### Task 8: Code Quality and Standards (Meta)
- Run Black formatter on all new Python files
- Run mypy --strict validation (0 errors required)
- Verify all functions have Google-style docstrings
- Check file sizes comply with ≤500 lines constraint

### Task 9: Final Validation and Integration (Meta)
- Run full plugin test suite (10+ new tests expected)
- Verify fixtures discoverable by pytest
- Test CI pipeline integration
- Review documentation completeness
- Backward compatibility check (existing tests still pass)
    </tasks>
  </story>

  <acceptanceCriteria>
1. MockTicketingToolPlugin created at tests/mocks/mock_plugin.py implementing all four abstract methods with configurable responses
2. Mock plugin supports configurable behaviors: success scenarios, failure modes (API errors, authentication errors, timeouts), and edge cases (empty responses, malformed payloads)
3. Plugin test fixtures created in tests/conftest.py: mock_servicedesk_plugin, mock_jira_plugin, mock_generic_plugin with pytest fixture best practices
4. Test utilities module created at tests/utils/plugin_test_helpers.py for: asserting plugin method calls, capturing plugin responses, simulating tool failures, validating TicketMetadata extraction
5. Integration test created: Full enhancement workflow with mock plugin (webhook validation → metadata extraction → context gathering → ticket update) demonstrating end-to-end mock usage
6. Documentation created: tests/README-plugins.md with testing guidelines, mock plugin usage examples, fixture patterns, best practices for plugin development testing
7. CI pipeline updated in .github/workflows/ to run plugin tests in isolation with clear separation between unit tests, integration tests, and mock-based tests
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic 7: Plugin Architecture & Multi-Tool Support</title>
        <section>Epic 7 Overview and Story 7.6 Definition (lines 1254-1385)</section>
        <snippet>Epic 7 refactors the platform to plugin-based architecture supporting multiple ticketing tools (Jira, Zendesk, ServiceDesk Plus). Story 7.6 creates testing framework with MockTicketingToolPlugin for testing enhancement workflows without real tool dependencies. Includes configurable behaviors (success, failure, timeout), test fixtures (mock_servicedesk_plugin, mock_jira_plugin), test utilities for assertions/response capture/failure simulation, integration tests demonstrating end-to-end mock usage, documentation (tests/README-plugins.md), and CI pipeline updates.</snippet>
      </doc>
      <doc>
        <path>docs/plugin-architecture.md</path>
        <title>Plugin Architecture Guide</title>
        <section>Overview, Architecture Pattern, Testing Guidelines (lines 1-100)</section>
        <snippet>Plugin architecture enables extensibility via TicketingToolPlugin ABC with four abstract methods: validate_webhook(), get_ticket(), update_ticket(), extract_metadata(). Plugin Manager routes requests by tenant tool_type. Benefits: compile-time safety with mypy, runtime flexibility, test plugins in isolation. Testing approach: unit tests (plugin methods isolated), integration tests (multi-component workflows with mock plugins), optional E2E tests (real tool sandboxes).</snippet>
      </doc>
      <doc>
        <path>tests/README.md</path>
        <title>Testing Guide</title>
        <section>Overview, Test Structure, Writing Tests, Fixtures (full file)</section>
        <snippet>Test suite uses pytest with pytest-asyncio. Organized: tests/unit/ (fast, isolated, mocked dependencies), tests/integration/ (Docker dependencies), tests/fixtures/ (reusable test data). Coverage target >80%. Basic patterns: @pytest.mark.asyncio for async tests, Arrange-Act-Assert structure, mock external APIs with unittest.mock.AsyncMock/patch. Fixtures in tests/conftest.py for reusable test data. Best practices: descriptive test names, test edge cases, keep tests fast (<100ms unit, <5s integration).</snippet>
      </doc>
      <doc>
        <path>Context7: /pytest-dev/pytest documentation</path>
        <title>Pytest Fixtures, Async Tests, Mocking Patterns, Parameterized Fixtures, Monkeypatch</title>
        <section>Latest 2025 pytest best practices from official docs</section>
        <snippet>Pytest 8.4+ best practices: Refactor mocks into fixtures for reusability (monkeypatch.setattr pattern). Parameterized fixtures with @pytest.fixture(params=[...]) for testing multiple scenarios. Async fixture deprecation warning: sync tests using async fixtures directly deprecated - wrap async fixture in sync fixture. Fixture scope: function (default, test isolation) vs session (shared setup). Monkeypatch for dependency injection: mock external APIs, environment variables, Path.home(). Factory methods via pytest.param with marks for conditional skipping. Call tracking: fixtures can store call history for assertion utilities.</snippet>
      </doc>
      <doc>
        <path>docs/stories/7-3-migrate-servicedesk-plus-to-plugin-architecture.md</path>
        <title>Story 7.3: ServiceDesk Plus Plugin Migration (Completed)</title>
        <section>Dev Notes - Testing Patterns Established</section>
        <snippet>Story 7.3 established plugin testing patterns: AsyncMock for async methods, patch pattern for external dependencies, fixtures for tenant configurations (mock_tenant_config), Arrange-Act-Assert structure. 19 unit tests + 8 integration tests + 12 backward compatibility tests all passing. Type safety: mypy --strict with 0 errors. File structure: plugin.py (488 lines), api_client.py (323 lines), webhook_validator.py (177 lines). Following 2025 httpx best practices: granular timeouts, exponential backoff, proper resource cleanup.</snippet>
      </doc>
      <doc>
        <path>docs/stories/7-5-update-database-schema-for-multi-tool-support.md</path>
        <title>Story 7.5: Database Schema Multi-Tool Support (Completed 2025-11-05)</title>
        <section>Dev Notes - Learnings from Testing Implementation</section>
        <snippet>Story 7.5 learnings: 10 unit tests in 0.10s (10ms/test, excellent performance). AsyncMock pattern for database session mocking, patch for TenantService/get_db_session/get_redis_client. Type safety requirements: mypy --strict 0 errors, Optional[] for nullable fields, Pydantic @model_validator for cross-field validation. Documentation: 349-line database-schema.md with ER diagrams, examples, troubleshooting. File size compliance: ≤500 lines (CLAUDE.md constraint). Code quality checklist: Black formatter, mypy validation, Google-style docstrings, test coverage >80%.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/plugins/base.py</path>
        <kind>interface</kind>
        <symbol>TicketingToolPlugin (ABC)</symbol>
        <lines>51-316</lines>
        <reason>Abstract base class defining plugin contract that MockTicketingToolPlugin must implement. Four abstract methods: validate_webhook() [async], get_ticket() [async], update_ticket() [async], extract_metadata() [sync]. MockTicketingToolPlugin will implement all four with configurable behaviors for testing.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/base.py</path>
        <kind>dataclass</kind>
        <symbol>TicketMetadata</symbol>
        <lines>18-48</lines>
        <reason>Standardized metadata structure returned by extract_metadata(). MockTicketingToolPlugin must return valid TicketMetadata instances. Fields: tenant_id, ticket_id, description, priority, created_at (datetime). Test utilities will validate these fields.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/registry.py</path>
        <kind>service</kind>
        <symbol>PluginManager (Singleton)</symbol>
        <lines>86-369</lines>
        <reason>Plugin registry that routes requests to appropriate plugins. MockTicketingToolPlugin will be registered here in tests. Methods: register_plugin(), get_plugin(), is_plugin_registered(), unregister_plugin(). Test fixtures need to patch PluginManager singleton for plugin routing tests.</reason>
      </artifact>
      <artifact>
        <path>tests/unit/test_servicedesk_plugin.py</path>
        <kind>test</kind>
        <symbol>servicedesk_plugin fixture</symbol>
        <lines>31-34</lines>
        <reason>Example plugin fixture pattern to follow. ServiceDesk Plus plugin fixture shows how to create reusable plugin instances for tests. Mock plugin fixtures (mock_generic_plugin, mock_servicedesk_plugin, mock_jira_plugin) will follow this pattern.</reason>
      </artifact>
      <artifact>
        <path>tests/unit/test_servicedesk_plugin.py</path>
        <kind>test</kind>
        <symbol>valid_webhook_payload fixture</symbol>
        <lines>37-50</lines>
        <reason>Example test data fixture pattern. Shows ServiceDesk Plus payload structure. Mock plugin test utilities will include payload builders (build_servicedesk_payload, build_jira_payload, build_generic_payload) following this pattern.</reason>
      </artifact>
      <artifact>
        <path>tests/conftest.py</path>
        <kind>config</kind>
        <symbol>pytest_configure hook</symbol>
        <lines>13-44</lines>
        <reason>Pytest configuration setting environment variables. Mock plugin fixtures will be added to this file. pytest_plugins list (line 93-95) for fixture discovery. Environment includes encryption keys, API keys, database URLs needed for plugin tests.</reason>
      </artifact>
      <artifact>
        <path>tests/conftest.py</path>
        <kind>config</kind>
        <symbol>env_vars fixture</symbol>
        <lines>83-89</lines>
        <reason>Monkeypatch helper for setting environment variables in tests. Mock plugin tests may use this for configuring tenant-specific settings during test execution.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/servicedesk_plus/plugin.py</path>
        <kind>component</kind>
        <symbol>ServiceDeskPlusPlugin class</symbol>
        <lines>full file</lines>
        <reason>Reference implementation of TicketingToolPlugin. MockTicketingToolPlugin will implement same interface but with configurable responses instead of real API calls. Shows pattern for async methods (validate_webhook, get_ticket, update_ticket) and sync method (extract_metadata).</reason>
      </artifact>
      <artifact>
        <path>src/plugins/servicedesk_plus/api_client.py</path>
        <kind>component</kind>
        <symbol>ServiceDeskAPIClient, ServiceDeskAPIError, ServiceDeskAuthenticationError</symbol>
        <lines>full file</lines>
        <reason>Exception types used by plugins. MockTicketingToolPlugin will raise these same exceptions in error modes (api_error_mode, auth_error_mode). Following 2025 httpx best practices: granular timeouts, exponential backoff, proper resource cleanup.</reason>
      </artifact>
      <artifact>
        <path>.github/workflows/ci.yml</path>
        <kind>config</kind>
        <symbol>lint-and-test job</symbol>
        <lines>24-100</lines>
        <reason>Existing CI pipeline structure. Story 7.6 Task 6 will add plugin test job or extend this job with plugin-specific test steps. Current steps: Black formatting, Ruff linting, Mypy type checking, Bandit security scanning. Plugin tests will add: pytest -m "unit and plugin", pytest -m "integration and plugin".</reason>
      </artifact>
      <artifact>
        <path>tests/integration/test_plugin_manager_integration.py</path>
        <kind>test</kind>
        <symbol>integration test examples</symbol>
        <lines>full file</lines>
        <reason>Existing integration test pattern for plugin manager. Shows how to test plugin registration and retrieval. Story 7.6 Task 4 integration test (test_mock_plugin_workflow.py) will follow this pattern but use MockTicketingToolPlugin instead of real plugins.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <runtime>
          <package name="python" version=">=3.12" />
          <package name="pydantic" version=">=2.5.0" note="For data validation in MockTicketingToolPlugin" />
          <package name="httpx" version=">=0.25.2" note="Following 2025 best practices for timeout/backoff patterns" />
        </runtime>
        <testing>
          <package name="pytest" version=">=7.4.3" note="Core testing framework" />
          <package name="pytest-asyncio" version=">=0.21.1" note="Required for async test functions (@pytest.mark.asyncio)" />
          <package name="pytest-mock" version=">=3.12.0" note="Enhanced mocking utilities for pytest" />
          <package name="pytest-httpx" version=">=0.22.0" note="For mocking httpx requests in plugin tests" />
        </testing>
        <dev>
          <package name="black" version=">=23.11.0" note="Code formatter (line-length=100)" />
          <package name="ruff" version=">=0.1.6" note="Fast linter (select: E, F, I, N, W)" />
          <package name="mypy" version=">=1.7.1" note="Static type checker (--strict mode required)" />
        </dev>
      </python>
      <frameworks>
        <framework name="pytest" note="Testing framework with fixtures, markers, parameterization support. Latest 2025 best practices from Context7 documentation." />
        <framework name="unittest.mock" note="Python standard library mocking (AsyncMock, MagicMock, patch)" />
        <framework name="asyncio" note="Python async/await for testing async plugin methods" />
      </frameworks>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="C1">File size limit: ≤500 lines per file (CLAUDE.md). If MockTicketingToolPlugin or plugin_test_helpers.py approach 500 lines, split into modules.</constraint>
    <constraint id="C2">Type safety required: All files must pass mypy --strict with 0 errors. Use Optional[] for nullable fields, proper type hints on all functions/methods.</constraint>
    <constraint id="C3">Google-style docstrings mandatory for all functions, classes, and methods per CLAUDE.md.</constraint>
    <constraint id="C4">Code formatting: Black formatter (line-length=100), PEP8 compliance enforced in CI.</constraint>
    <constraint id="C5">Test performance targets: Unit tests <100ms each, integration tests <5s each, full suite <10s for Story 7.6 tests.</constraint>
    <constraint id="C6">Pytest 8.4+ compatibility: Avoid deprecated async fixture patterns. Sync tests using async fixtures must wrap in sync fixture.</constraint>
    <constraint id="C7">Mock plugin must implement all four abstract methods from TicketingToolPlugin ABC: validate_webhook(), get_ticket(), update_ticket(), extract_metadata().</constraint>
    <constraint id="C8">Test isolation: Each test gets fresh mock plugin instance. Use scope="function" (default) for plugin fixtures to ensure clean call history.</constraint>
    <constraint id="C9">No real API calls in tests: MockTicketingToolPlugin must NOT make external HTTP requests. All responses configurable via constructor parameters.</constraint>
    <constraint id="C10">Backward compatibility: All existing plugin tests (test_servicedesk_plugin.py, test_jira_plugin.py, test_plugin_manager_integration.py) must continue passing after adding mock plugin fixtures.</constraint>
    <constraint id="C11">Security: No hardcoded secrets in mock plugin or test files. Use environment variables or fixture-provided test keys only.</constraint>
    <constraint id="C12">CI integration: Plugin tests must run in GitHub Actions with clear separation (unit/integration/mock markers). Test failures should not block unrelated tests.</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>TicketingToolPlugin.validate_webhook</name>
      <kind>async method</kind>
      <signature>async def validate_webhook(self, payload: Dict[str, Any], signature: str) -> bool</signature>
      <path>src/plugins/base.py:104-147</path>
      <note>MockTicketingToolPlugin must implement this. Return _validate_response (bool) configured in constructor. Support configurable failures: _raise_timeout (asyncio.TimeoutError), _raise_auth_error (ValidationError).</note>
    </interface>
    <interface>
      <name>TicketingToolPlugin.get_ticket</name>
      <kind>async method</kind>
      <signature>async def get_ticket(self, tenant_id: str, ticket_id: str) -> Optional[Dict[str, Any]]</signature>
      <path>src/plugins/base.py:149-201</path>
      <note>MockTicketingToolPlugin must implement this. Return _get_ticket_response (Dict | None) configured in constructor. Support configurable failures: _raise_api_error (ServiceDeskAPIError), _raise_timeout (asyncio.TimeoutError). Return None for not_found_mode.</note>
    </interface>
    <interface>
      <name>TicketingToolPlugin.update_ticket</name>
      <kind>async method</kind>
      <signature>async def update_ticket(self, tenant_id: str, ticket_id: str, content: str) -> bool</signature>
      <path>src/plugins/base.py:203-256</path>
      <note>MockTicketingToolPlugin must implement this. Return _update_ticket_response (bool) configured in constructor. Support configurable failures: _raise_api_error (ServiceDeskAPIError), _raise_timeout (asyncio.TimeoutError).</note>
    </interface>
    <interface>
      <name>TicketingToolPlugin.extract_metadata</name>
      <kind>sync method</kind>
      <signature>def extract_metadata(self, payload: Dict[str, Any]) -> TicketMetadata</signature>
      <path>src/plugins/base.py:258-316</path>
      <note>MockTicketingToolPlugin must implement this (synchronous, not async). Extract tenant_id, ticket_id from payload with fallback defaults. Return TicketMetadata dataclass with normalized priority (lowercase: "high", "medium", "low"), created_at as UTC datetime. Handle malformed payloads gracefully (missing keys use defaults).</note>
    </interface>
    <interface>
      <name>TicketMetadata dataclass</name>
      <kind>dataclass</kind>
      <signature>@dataclass class TicketMetadata: tenant_id: str, ticket_id: str, description: str, priority: str, created_at: datetime</signature>
      <path>src/plugins/base.py:18-48</path>
      <note>Standard metadata structure returned by extract_metadata(). Test utility assert_ticket_metadata_valid() must validate all required fields present, priority normalized, created_at has timezone.</note>
    </interface>
    <interface>
      <name>PluginManager.register_plugin</name>
      <kind>method</kind>
      <signature>def register_plugin(self, tool_type: str, plugin: TicketingToolPlugin) -> None</signature>
      <path>src/plugins/registry.py:131-177</path>
      <note>Test fixtures will use this to register MockTicketingToolPlugin instances. Validates tool_type is non-empty string, plugin is instance of TicketingToolPlugin ABC.</note>
    </interface>
    <interface>
      <name>PluginManager.get_plugin</name>
      <kind>method</kind>
      <signature>def get_plugin(self, tool_type: str) -> TicketingToolPlugin</signature>
      <path>src/plugins/registry.py:179-211</path>
      <note>Test utilities will use this to retrieve registered mock plugins. Raises PluginNotFoundError if tool_type not registered. Integration tests will mock this method to return MockTicketingToolPlugin.</note>
    </interface>
    <interface>
      <name>pytest fixture pattern</name>
      <kind>test fixture</kind>
      <signature>@pytest.fixture(scope="function") def mock_generic_plugin() -> MockTicketingToolPlugin</signature>
      <path>tests/conftest.py (to be added)</path>
      <note>Pytest fixture best practices from Context7: Use scope="function" for test isolation, yield pattern for cleanup, factory pattern for parameterization. All mock plugin fixtures follow this pattern.</note>
    </interface>
  </interfaces>
  <tests>
    <standards>
The project uses pytest with pytest-asyncio for async support. Testing standards from tests/README.md and CLAUDE.md:

**Test Organization:**
- Unit tests in tests/unit/ - fast, isolated, mocked dependencies (<100ms per test)
- Integration tests in tests/integration/ - real Docker dependencies (<5s per test)
- Fixtures in tests/conftest.py and tests/fixtures/ for reusable test data

**Test Structure (Arrange-Act-Assert):**
1. Arrange: Setup test data and mocks
2. Act: Perform action under test
3. Assert: Verify expected results

**Naming Convention:** test_<component>_<scenario>_<expected_result>
Examples: test_mock_plugin_success_mode(), test_mock_plugin_api_error_mode()

**Async Tests:** Use @pytest.mark.asyncio decorator for async test functions. Pytest 8.4+ deprecates sync tests using async fixtures directly - wrap async fixtures in sync fixtures.

**Mocking:** Use unittest.mock.AsyncMock for async methods, unittest.mock.patch for dependency injection, monkeypatch fixture for environment variables.

**Pytest Markers:** Define in pyproject.toml [tool.pytest.ini_options].markers. Story 7.6 adds: "unit", "integration", "plugin" markers for selective test execution.

**Type Safety:** All test files must pass mypy --strict. Use proper type hints for fixtures and test functions.

**Code Quality:** Black formatter (line-length=100), Ruff linter, Google-style docstrings mandatory.

**Coverage Target:** >80% for new code. Use pytest --cov=src --cov-report=html.

**Pytest Best Practices from Context7 (/pytest-dev/pytest):**
- Refactor mocks into fixtures for reusability (avoid repeating monkeypatch.setattr in every test)
- Use fixture scope="function" (default) for test isolation with stateful mocks
- Parameterized fixtures with @pytest.fixture(params=[...]) for testing multiple scenarios
- Factory pattern: Create factory methods in MockTicketingToolPlugin (success_mode, api_error_mode, etc.)
- Call tracking: Built-in call history in mock plugin (not unittest.mock.assert_called_once_with)
    </standards>
    <locations>
tests/mocks/mock_plugin.py - MockTicketingToolPlugin class (NEW, AC1)
tests/utils/plugin_test_helpers.py - Test utility functions (NEW, AC4)
tests/conftest.py - Plugin test fixtures (EXTEND, AC3)
tests/unit/test_mock_plugin.py - Unit tests for MockTicketingToolPlugin (NEW, Task 7)
tests/integration/test_mock_plugin_workflow.py - Integration test with full workflow (NEW, AC5)
tests/README-plugins.md - Plugin testing documentation (NEW, AC6)
.github/workflows/ci.yml - CI pipeline updates for plugin tests (EXTEND, AC7)
pyproject.toml - Pytest marker definitions: unit, integration, plugin (EXTEND, Task 6)
    </locations>
    <ideas>
**AC1: MockTicketingToolPlugin Implementation**
- Test MockTicketingToolPlugin.success_mode() returns valid responses for all four methods
- Test MockTicketingToolPlugin.api_error_mode() raises ServiceDeskAPIError for get_ticket/update_ticket
- Test MockTicketingToolPlugin.auth_error_mode() raises ValidationError for validate_webhook
- Test MockTicketingToolPlugin.timeout_mode() raises asyncio.TimeoutError for all async methods
- Test MockTicketingToolPlugin.not_found_mode() returns None for get_ticket
- Test custom configuration: plugin with specific _get_ticket_response, _validate_response=False
- Test call tracking: verify all method calls recorded in _call_history with correct args/kwargs
- Test reset_call_history() clears tracking between tests

**AC2: Configurable Behaviors**
- Test success scenario: validate_webhook returns True, get_ticket returns ticket dict, update_ticket returns True
- Test API error: get_ticket raises ServiceDeskAPIError with retry count
- Test authentication error: validate_webhook raises ValidationError with "Mock authentication failure"
- Test timeout: async methods await asyncio.sleep(10) then raise TimeoutError
- Test edge case: get_ticket with _get_ticket_response=None returns None (ticket not found)
- Test malformed payload: extract_metadata handles missing keys gracefully (use defaults)

**AC3: Plugin Test Fixtures**
- Test mock_generic_plugin fixture provides clean MockTicketingToolPlugin instance per test
- Test mock_servicedesk_plugin fixture has ServiceDesk Plus-style payload defaults
- Test mock_jira_plugin fixture has Jira webhook payload structure
- Test plugin_failure_mode parameterized fixture iterates through all failure modes
- Test fixture scope="function" ensures test isolation (no state leakage between tests)
- Test fixtures are discoverable by pytest (pytest --fixtures | grep mock_plugin)

**AC4: Test Utilities**
- Test assert_plugin_called(plugin, "validate_webhook", times=1) verifies call count
- Test assert_plugin_called_with(plugin, "get_ticket", tenant_id="tenant-1", ticket_id="123")
- Test capture_plugin_response() returns (result, exception, duration_ms) tuple
- Test configure_plugin_failure(plugin, "api_error") sets appropriate flags
- Test assert_ticket_metadata_valid() validates all required fields, normalized priority, timezone
- Test payload builders: build_servicedesk_payload(**overrides), build_jira_payload(**overrides)

**AC5: Integration Test - Full Enhancement Workflow**
- Test webhook validation phase: plugin.validate_webhook(payload, signature) returns True
- Test metadata extraction phase: plugin.extract_metadata(payload) returns valid TicketMetadata
- Test ticket retrieval phase: plugin.get_ticket(tenant_id, ticket_id) returns ticket dict
- Test ticket update phase: plugin.update_ticket(tenant_id, ticket_id, content) returns True
- Test failure mode: API error during get_ticket raises ServiceDeskAPIError
- Test failure mode: Timeout during update_ticket raises asyncio.TimeoutError (with 1s timeout)
- Test edge case: Ticket not found (None response) handled gracefully

**AC6: Documentation**
- Verify tests/README-plugins.md exists with all sections (Overview, Usage Guide, Fixtures, Utilities, Best Practices, Examples, Troubleshooting)
- Verify code examples in documentation are accurate (copy-paste test)
- Verify all utilities documented with usage examples
- Verify best practices section includes: test isolation, test both paths, call tracking, validate metadata

**AC7: CI Pipeline Integration**
- Verify pytest -m "unit and plugin" runs only plugin unit tests
- Verify pytest -m "integration and plugin" runs only plugin integration tests
- Verify GitHub Actions workflow runs plugin tests in separate step
- Verify test markers defined in pyproject.toml
- Verify backward compatibility: existing tests (test_servicedesk_plugin.py, test_jira_plugin.py) still pass
    </ideas>
  </tests>
</story-context>
