<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.4</storyId>
    <title>Implement Input Validation and Sanitization</title>
    <status>drafted</status>
    <generatedAt>2025-11-03</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/3-4-implement-input-validation-and-sanitization.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a security engineer</asA>
    <iWant>all webhook and API inputs validated and sanitized</iWant>
    <soThat>injection attacks and malformed data are prevented</soThat>
    <tasks>
### Task 1: Create Pydantic Input Validation Models (AC: 1)
- Define WebhookPayload Pydantic model for ticket creation
- Define ResolvedTicketPayload Pydantic model for ticket resolution webhook
- Update existing webhook endpoints to use new models
- Add custom validators for business logic

### Task 2: Implement String Sanitization Utilities (AC: 2)
- Create sanitization utility module
- Implement HTML entity encoding for output
- Integrate sanitization into webhook processing
- Verify SQLAlchemy ORM prevents SQL injection

### Task 3: Add Input Length Validation (AC: 3)
- Define length constants in configuration
- Apply length constraints in Pydantic models
- Test oversized input rejection

### Task 4: Implement Custom Error Responses (AC: 4)
- Create custom exception handler for validation errors
- Define custom business validation exceptions
- Ensure error messages don't leak system internals
- Add error response examples to API documentation

### Task 5: Handle Special Characters Safely (AC: 5)
- Define allowlist of safe special characters
- Implement safe character validation
- Apply HTML entity encoding for output contexts
- Test edge cases with special characters

### Task 6: Create Comprehensive Unit Test Suite (AC: 6)
- Create test file for input validation
- Write tests for valid input scenarios
- Write tests for invalid type scenarios
- Write tests for oversized input scenarios
- Write tests for injection attempt scenarios
- Write tests for sanitization utilities

### Task 7: Integrate Security Scanning Tool (Bandit) into CI Pipeline (AC: 7)
- Install and configure Bandit
- Create Bandit configuration file
- Run Bandit locally and fix any issues
- Add Bandit step to GitHub Actions CI pipeline
- Document security scanning process
</tasks>
  </story>

  <acceptanceCriteria>
1. **Pydantic Models Enforce Strict Typing for All Input Fields**
   - All webhook endpoints use Pydantic models for request validation
   - Strict types defined (str, int, UUID, HttpUrl, EmailStr, datetime with timezone)
   - Invalid request types return 422 with validation error details
   - Pydantic Field() validators for additional constraints

2. **String Inputs Sanitized to Prevent SQL Injection and XSS**
   - SQLAlchemy ORM used for all database operations
   - No raw SQL queries except in migrations
   - HTML special characters escaped before storage or display
   - Test coverage for SQL injection and XSS attempts

3. **Input Length Limits Enforced (Max 10,000 Chars for Ticket Description)**
   - Ticket description: 10,000 chars max
   - Ticket ID: 100 chars max
   - Tenant ID: 100 chars max
   - Resolution: 20,000 chars max
   - URLs: 500 chars max

4. **Invalid Input Returns 400 Bad Request with Validation Errors**
   - FastAPI returns 422 for type errors
   - Custom validation errors return 400 for business logic failures
   - Informative error messages that don't leak system internals
   - All validation failures logged with WARNING level

5. **Special Characters in Ticket Descriptions Handled Safely**
   - Common special characters allowed (', ", <>, &)
   - Unicode characters supported
   - Null bytes and control characters rejected
   - HTML entity encoding applied when content returned in API responses

6. **Unit Tests Cover Valid Input, Invalid Types, Oversized Input, Injection Attempts**
   - Minimum 20 test cases in tests/unit/test_input_validation.py
   - Tests for valid inputs, invalid types, oversized inputs, injection attempts
   - Edge cases covered (empty strings, null values, special Unicode)
   - 100% test success rate

7. **Security Scanning Tool Integrated into CI Pipeline**
   - Bandit installed and configured
   - Runs in GitHub Actions CI on every pull request
   - High and medium severity issues block PR merges
   - Low severity issues logged as warnings
</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>AI Agents - Decision Architecture</title>
        <section>Technology Stack Details - Backend API</section>
        <snippet>FastAPI 0.104+ with Pydantic 2.x for data validation and automatic OpenAPI documentation. Architecture prioritizes production readiness and observability.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>AI Agents - Epic Breakdown</title>
        <section>Epic 3: Multi-Tenancy & Security - Story 3.4</section>
        <snippet>Story 3.4 implements comprehensive input validation for webhook endpoints using Pydantic models, sanitization utilities, and security scanning with Bandit.</snippet>
      </doc>
      <doc>
        <path>External: FastAPI Request Body Documentation</path>
        <title>FastAPI Tutorial - Request Body</title>
        <section>Pydantic Model Validation</section>
        <snippet>FastAPI automatically validates request bodies using Pydantic models, returning 422 Unprocessable Entity for invalid data. Models inherit from BaseModel and use standard Python types with automatic JSON schema generation.</snippet>
        <url>https://fastapi.tiangolo.com/tutorial/body/</url>
      </doc>
      <doc>
        <path>External: Pydantic Field Validators</path>
        <title>Pydantic v2 - Field Validators</title>
        <section>After/Before/Plain/Wrap Validators</section>
        <snippet>Pydantic v2 offers four validator types: AfterValidator (runs after Pydantic validation), BeforeValidator (runs before parsing), PlainValidator (terminates validation immediately), and WrapValidator (most flexible). Use @field_validator decorator or Annotated pattern.</snippet>
        <url>https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#field-validators</url>
      </doc>
      <doc>
        <path>External: OWASP Input Validation Cheat Sheet</path>
        <title>OWASP Input Validation Best Practices</title>
        <section>Allowlist vs Denylist Strategy</section>
        <snippet>Use allowlist validation defining exactly what IS authorized. Input validation should enforce syntactic (correct syntax/format) and semantic (correct values in business context) validation. Server-side validation is mandatory; client-side is optional for UX only.</snippet>
        <url>https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html</url>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/schemas/webhook.py</path>
        <kind>schema</kind>
        <symbol>WebhookPayload</symbol>
        <lines>14-80</lines>
        <reason>Existing Pydantic model for webhook validation. Story 3.4 will enhance with strict field validators, length constraints, and sanitization integration.</reason>
      </artifact>
      <artifact>
        <path>src/schemas/webhook.py</path>
        <kind>schema</kind>
        <symbol>ResolvedTicketWebhook</symbol>
        <lines>83-179</lines>
        <reason>Existing Pydantic model for resolved ticket webhooks. Story 3.4 will apply same validation enhancements as WebhookPayload.</reason>
      </artifact>
      <artifact>
        <path>src/api/webhooks.py</path>
        <kind>endpoint</kind>
        <symbol>receive_webhook</symbol>
        <lines>30-165</lines>
        <reason>Primary webhook endpoint that uses WebhookPayload model. Story 3.4 will integrate sanitization and custom validation error handling.</reason>
      </artifact>
      <artifact>
        <path>src/api/webhooks.py</path>
        <kind>endpoint</kind>
        <symbol>store_resolved_ticket</symbol>
        <lines>168-250</lines>
        <reason>Resolved ticket endpoint using ResolvedTicketWebhook model. Will apply same validation patterns as receive_webhook.</reason>
      </artifact>
      <artifact>
        <path>src/utils/exceptions.py</path>
        <kind>utility</kind>
        <symbol>ValidationError</symbol>
        <lines>27-39</lines>
        <reason>Existing custom exception class for validation failures. Story 3.4 will extend this pattern for business logic validation failures.</reason>
      </artifact>
      <artifact>
        <path>src/config.py</path>
        <kind>configuration</kind>
        <symbol>Settings</symbol>
        <lines>Variable</lines>
        <reason>Pydantic Settings class using BaseSettings. Story 3.4 will add validation constants (MAX_TICKET_DESCRIPTION_LENGTH, etc.) here or in new constants.py.</reason>
      </artifact>
      <artifact>
        <path>src/database/models.py</path>
        <kind>model</kind>
        <symbol>All SQLAlchemy models</symbol>
        <lines>All</lines>
        <reason>SQLAlchemy ORM models prevent SQL injection by design. Story 3.4 Task 2.4 will audit to confirm no raw SQL queries exist in application code.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="fastapi" version=">=0.104.0">ASGI web framework with automatic Pydantic validation and OpenAPI generation</package>
        <package name="pydantic" version=">=2.5.0">Data validation library with v2 performance improvements and field validators</package>
        <package name="pydantic-settings" version=">=2.1.0">Settings management using Pydantic BaseSettings</package>
        <package name="sqlalchemy" version=">=2.0.23">Async ORM preventing SQL injection through parameterized queries</package>
        <package name="pytest" version=">=7.4.3">Testing framework for unit and integration tests</package>
        <package name="pytest-asyncio" version=">=0.21.1">Async test support for FastAPI endpoint testing</package>
      </python>
      <new_dependencies>
        <package name="bandit[toml]" version="latest">Python security linter for CI pipeline integration (Task 7)</package>
      </new_dependencies>
    </dependencies>
  </artifacts>

  <constraints>
    <architecture>
      <constraint>FastAPI + Pydantic Validation Strategy: Leverage FastAPI automatic validation via Pydantic models for type safety and automatic 422 responses. Use Pydantic v2 Field validators for custom business logic.</constraint>
      <constraint>Defense-in-Depth Security: Layer 1 (Pydantic type validation), Layer 2 (Sanitization), Layer 3 (SQLAlchemy ORM), Layer 4 (HTML entity encoding on output), Layer 5 (RLS policies from Story 3.1).</constraint>
      <constraint>OWASP Best Practices: Use allowlist validation defining what IS allowed. Server-side validation is mandatory. Fail securely with generic client-facing error messages and detailed server logs.</constraint>
      <constraint>Separation of Concerns: Pydantic handles syntactic validation (types, formats), application code handles semantic validation (business rules).</constraint>
    </architecture>
    <project_structure>
      <constraint>Validation schemas in src/schemas/ following established pattern</constraint>
      <constraint>Utilities in src/utils/ (sanitization.py, constants.py)</constraint>
      <constraint>Tests mirror source structure: tests/unit/test_input_validation.py, tests/unit/test_sanitization.py</constraint>
      <constraint>Middleware in src/api/middleware.py (established in Epic 2)</constraint>
    </project_structure>
    <coding_standards>
      <constraint>Black formatting with 100 char line length (pyproject.toml)</constraint>
      <constraint>Ruff linting with py312 target (pyproject.toml)</constraint>
      <constraint>Type hints required (mypy strict mode)</constraint>
      <constraint>Google-style docstrings for all functions</constraint>
      <constraint>No files longer than 500 lines (CLAUDE.md)</constraint>
    </coding_standards>
    <validation_requirements>
      <constraint>Max lengths: ticket_description=10000, ticket_id=100, tenant_id=100, resolution=20000, url=500</constraint>
      <constraint>Ticket ID format: alphanumeric + dashes (e.g., "TKT-12345")</constraint>
      <constraint>Tenant ID format: lowercase alphanumeric + dashes (e.g., "tenant-abc")</constraint>
      <constraint>DateTime fields must have timezone (reject naive datetimes)</constraint>
      <constraint>Priority enum: ["low", "medium", "high", "critical"] only</constraint>
      <constraint>Model config extra="forbid" to reject unknown fields (prevent parameter pollution)</constraint>
    </validation_requirements>
  </constraints>
  <interfaces>
    <endpoint>
      <name>POST /webhook/servicedesk</name>
      <kind>REST endpoint</kind>
      <signature>async def receive_webhook(payload: WebhookPayload, db: AsyncSession, queue_service: QueueService, tenant_config: TenantConfigInternal) -> dict[str, str]</signature>
      <path>src/api/webhooks.py:30-165</path>
      <modification>Apply Pydantic WebhookPayload model with enhanced validators, integrate sanitization, handle custom validation errors</modification>
    </endpoint>
    <endpoint>
      <name>POST /webhook/servicedesk/resolved</name>
      <kind>REST endpoint</kind>
      <signature>async def store_resolved_ticket(payload: ResolvedTicketWebhook, db: AsyncSession) -> dict[str, str]</signature>
      <path>src/api/webhooks.py:168-250</path>
      <modification>Apply Pydantic ResolvedTicketWebhook model with same validation enhancements as WebhookPayload</modification>
    </endpoint>
    <model>
      <name>WebhookPayload</name>
      <kind>Pydantic BaseModel</kind>
      <signature>class WebhookPayload(BaseModel): event: str, ticket_id: str, tenant_id: str, description: str, priority: Literal, created_at: datetime</signature>
      <path>src/schemas/webhook.py:14-80</path>
      <modification>Add @field_validator decorators for ticket_id format, tenant_id format, datetime timezone validation. Add Field constraints for max_length. Configure model_config with extra="forbid".</modification>
    </model>
    <model>
      <name>ResolvedTicketWebhook</name>
      <kind>Pydantic BaseModel</kind>
      <signature>class ResolvedTicketWebhook(BaseModel): tenant_id: str, ticket_id: str, subject: str, description: str, resolution: str, resolved_date: datetime, priority: Literal, tags: list[str]</signature>
      <path>src/schemas/webhook.py:83-179</path>
      <modification>Apply same field validators and constraints as WebhookPayload. Add max_length=20000 for resolution field.</modification>
    </model>
  </interfaces>
  <tests>
    <standards>
      Testing framework: Pytest with pytest-asyncio for async support (pyproject.toml config).
      Test structure mirrors source: tests/unit/ for unit tests, tests/integration/ for integration tests.
      Fixtures defined in tests/conftest.py for database, Redis, environment variables (established pattern).
      Pytest parametrize for testing multiple invalid inputs with single test function.
      Async test functions use @pytest.mark.asyncio decorator (automatically applied via asyncio_mode="auto" in config).
      Target: 100% test pass rate with minimum 20 test cases for Story 3.4.
      Code coverage tracking with comprehensive edge case testing (Story 2.12 achieved 100% pass rate pattern).
    </standards>
    <locations>
      tests/unit/test_input_validation.py - Main validation test suite (to be created)
      tests/unit/test_sanitization.py - Sanitization utility tests (to be created)
      tests/conftest.py - Centralized fixtures for test database, Redis, environment variables (exists)
      tests/unit/ - Unit test directory (exists)
      tests/integration/ - Integration test directory (exists)
    </locations>
    <ideas>
      <test_group ac="1" description="Pydantic Model Validation">
        Test valid WebhookPayload with all required fields â†’ passes validation
        Test valid ResolvedTicketPayhook â†’ passes validation
        Test optional fields omitted â†’ passes validation
        Test max length inputs (9,999 chars) â†’ passes validation
        Test ticket_id as integer instead of string â†’ 422 error
        Test created_at as string instead of datetime â†’ 422 error
        Test priority="super-high" (invalid enum) â†’ 422 error
        Test extra unexpected fields with extra="forbid" â†’ 422 error
      </test_group>
      <test_group ac="2" description="String Sanitization">
        Test sanitize_text removes null bytes â†’ "\x00" removed
        Test sanitize_text removes control characters except \n, \t â†’ cleaned output
        Test escape_html escapes < > & " ' â†’ HTML entities
        Test escape_html preserves normal text â†’ unchanged
        Test SQL injection in description: "'; DROP TABLE tickets; --" â†’ sanitized, no SQL execution
        Test XSS in description: "<script>alert(1)</script>" â†’ escaped on output
      </test_group>
      <test_group ac="3" description="Input Length Validation">
        Test description with 10,001 characters â†’ 422 error with "max_length" in message
        Test ticket_id with 101 characters â†’ 422 error
        Test URL with 501 characters â†’ 422 error
        Test description at exactly 10,000 characters â†’ passes validation
      </test_group>
      <test_group ac="4" description="Custom Error Responses">
        Test FastAPI ValidationError returns consistent format â†’ {"detail": [...], "error_type": "validation_error"}
        Test custom business validation exception â†’ 400 Bad Request
        Test validation errors logged with WARNING level â†’ log entry created
        Test error messages don't leak system internals â†’ no table names, file paths, stack traces
      </test_group>
      <test_group ac="5" description="Special Characters">
        Test legitimate technical content: "if (x < 10 && y > 5)" â†’ passes
        Test company names: "AT&T", "O'Reilly Media" â†’ passes
        Test international text: "æ—¥æœ¬èªž", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "ÐŸÑ€Ð¸Ð²ÐµÑ‚" â†’ passes
        Test emoji: "ðŸ”¥ðŸš€" â†’ passes
        Test null byte injection: "test\x00DROP TABLE" â†’ rejected
        Test path traversal in ticket_id: "../../etc/passwd" â†’ rejected (invalid format)
      </test_group>
      <test_group ac="7" description="Security Scanning Integration">
        Test Bandit runs successfully on codebase â†’ zero high/medium severity issues
        Test Bandit CI step fails on high severity issue â†’ CI pipeline fails
        Test Bandit excludes tests/ directory â†’ no false positives from test code
      </test_group>
    </ideas>
  </tests>
</story-context>
