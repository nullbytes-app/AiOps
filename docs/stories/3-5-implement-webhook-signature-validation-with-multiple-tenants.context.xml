<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.5</storyId>
    <title>Implement Webhook Signature Validation with Multiple Tenants</title>
    <status>drafted</status>
    <generatedAt>2025-11-03</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/3-5-implement-webhook-signature-validation-with-multiple-tenants.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>platform operator</asA>
    <iWant>each tenant to have unique webhook signing secrets</iWant>
    <soThat>tenant A cannot spoof webhooks for tenant B</soThat>
    <tasks>
### Task 1: Update Database Schema for Per-Tenant Webhook Secrets (AC: 1)
- Create Alembic migration for webhook_signing_secret column
- Update TenantConfig SQLAlchemy model
- Update TenantConfigService for secret management
- Update tenant creation flow to generate secrets

### Task 2: Implement Tenant-Specific Signature Validation (AC: 2, 3)
- Create signature validation utility function
- Implement constant-time signature comparison
- Enhance webhook validation to extract tenant_id first
- Implement end-to-end signature validation flow
- Integrate signature validation into webhook endpoints

### Task 3: Implement Replay Attack Prevention with Timestamp Validation (AC: 5)
- Define timestamp tolerance configuration
- Implement timestamp validation function
- Integrate timestamp validation into signature validation flow
- Update Pydantic webhook models to enforce timezone

### Task 4: Implement Error Handling and Security Logging (AC: 4)
- Define custom exceptions for signature validation failures
- Implement structured security event logging
- Create FastAPI exception handlers for webhook errors
- Implement Prometheus metrics for signature failures

### Task 5: Implement Rate Limiting with Redis Sliding Window (AC: 6)
- Create rate limiting utility function
- Implement Redis sliding window logic
- Integrate rate limiting into webhook endpoints
- Add per-tenant rate limit configuration
- Implement Prometheus metrics for rate limiting

### Task 6: Create Comprehensive Security Test Suite (AC: 7)
- Create integration test file for webhook security
- Write cross-tenant spoofing prevention tests
- Write timestamp validation tests
- Write tenant identification tests
- Write rate limiting tests
- Write unit tests for validation utilities

### Task 7: Update Documentation and Operational Procedures (AC: 1, 4)
- Document webhook secret management in operator guide
- Document signature computation for ServiceDesk Plus configuration
- Document security event logging and monitoring
- Update API documentation (OpenAPI/Swagger)
    </tasks>
  </story>

  <acceptanceCriteria>
1. **Webhook Signing Secret Stored Per Tenant in tenant_configs**: tenant_configs table includes webhook_signing_secret column (TEXT, encrypted), generated automatically during tenant creation (64 characters, base64-encoded random bytes), unique per tenant, retrievable via TenantConfigService.get_webhook_secret(tenant_id)

2. **Signature Validation Uses Tenant-Specific Secret**: validate_webhook_signature(request: Request, tenant_id: str) -> bool function using HMAC-SHA256 algorithm, signature computed from HMAC(webhook_secret, request_body_bytes), constant-time comparison, returns True if valid, location: src/services/webhook_validator.py

3. **Tenant Identified from Webhook Payload Before Signature Check**: Webhook payload must include tenant_id field, lightweight parsing to extract only tenant_id from JSON body, tenant existence validated against tenant_configs table, unknown tenant_id returns 404 Not Found, inactive tenants rejected with 403 Forbidden, tenant lookup cached in Redis (5-minute TTL)

4. **Invalid Signatures Return 401 with Logged Security Event**: HTTP status 401 Unauthorized for signature mismatch, security event logged at ERROR level with timestamp/tenant_id/source_ip/endpoint/error_type, Prometheus metric incremented: webhook_signature_failures_total{tenant_id, endpoint}, rate limiting applied: max 10 failed attempts per tenant per minute

5. **Signature Replay Attack Prevented (Timestamp Validation)**: Webhook payload must include created_at timestamp (ISO 8601 with timezone), timestamp included in HMAC signature computation, request rejected if timestamp older than 5 minutes or in future (30 seconds tolerance), replay prevention logic: abs(now() - created_at) > tolerance → reject with 401

6. **Rate Limiting Added (Max 100 Webhooks/Min Per Tenant)**: Redis sliding window algorithm, key format: webhook_rate_limit:{tenant_id}:{endpoint}, limit: 100 requests per 60-second window per tenant, exceeded limit returns 429 Too Many Requests with Retry-After header, rate limits configurable per tenant in tenant_configs.rate_limits JSONB field

7. **Security Tests Verify Cross-Tenant Spoofing Prevention**: Test suite tests/integration/test_webhook_security.py includes 7+ tests covering tenant A/B secret validation, invalid signatures, expired timestamps, unknown tenants, rate limiting (101st webhook rejected)
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- External Documentation from MCP Tools -->
      <doc>
        <path>https://www.authgear.com/post/hmac-api-security</path>
        <title>Why HMAC Is Still a Must-Have for API Security in 2025 - Authgear</title>
        <section>Best Practices</section>
        <snippet>Always use SHA256 or stronger. Avoid SHA1; it's no longer considered secure. Include a timestamp in signed messages. Use constant-time comparison. In Node.js, use crypto.timingSafeEqual; in Python, use hmac.compare_digest. Rotate secrets periodically. Never send the secret key in API responses or logs.</snippet>
      </doc>
      <doc>
        <path>https://redis.io/docs/latest/commands/incr/#pattern-rate-limiter-1</path>
        <title>Redis Rate Limiter Pattern</title>
        <section>Pattern: Rate limiter 1</section>
        <snippet>Counter for every IP/tenant per second with MULTI/EXEC for atomic increment and EXPIRE. Keys automatically removed when expired. Simple and direct implementation for rate limiting.</snippet>
      </doc>

      <!-- Project Documentation -->
      <doc>
        <path>docs/architecture.md</path>
        <title>AI Agents - Decision Architecture</title>
        <section>Technology Stack</section>
        <snippet>FastAPI 0.104+, Pydantic 2.x, PostgreSQL 17 with row-level security, SQLAlchemy 2.0+, Redis 7.x, Celery 5.x, HTTPX async HTTP client, Loguru logging, Prometheus metrics. Multi-tenant AI-powered ticket enhancement platform.</snippet>
      </doc>
      <doc>
        <path>docs/security-rls.md</path>
        <title>Row-Level Security (RLS) Implementation</title>
        <section>Architecture - Session Variable Pattern</section>
        <snippet>RLS policies filter rows based on session variable app.current_tenant_id. Helper function set_tenant_context(tenant_id) validates tenant exists and sets session variable securely. Protected tables: tenant_configs, enhancement_history, ticket_history, system_inventory.</snippet>
      </doc>
      <doc>
        <path>docs/webhook-signature-setup.md</path>
        <title>Webhook Signature Validation Setup</title>
        <section>Security Architecture</section>
        <snippet>Algorithm: HMAC-SHA256, Header: X-ServiceDesk-Signature, Secret: AI_AGENTS_WEBHOOK_SECRET (env variable), validation with constant-time comparison, invalid signatures rejected with 401 Unauthorized. Implementation uses hmac.compare_digest() to prevent timing attacks.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Story 2.2: Implement Webhook Signature Validation</title>
        <section>Multi-Tenancy & Security - Epic 3</section>
        <snippet>Original Story 2.2 implemented single-tenant HMAC-SHA256 signature validation. Story 3.5 extends this to per-tenant webhook signing secrets to prevent cross-tenant spoofing attacks. Each tenant gets unique secret in tenant_configs table.</snippet>
      </doc>
    </docs>

    <code>
      <!-- Existing Code Artifacts -->
      <artifact>
        <path>src/database/models.py</path>
        <kind>model</kind>
        <symbol>TenantConfig</symbol>
        <lines>29-103</lines>
        <reason>TenantConfig model already includes webhook_signing_secret_encrypted field (Story 3.3). Need to add methods for secret generation, retrieval, and rotation. Model uses SQLAlchemy declarative style with encrypted fields.</reason>
      </artifact>
      <artifact>
        <path>src/services/webhook_validator.py</path>
        <kind>service</kind>
        <symbol>validate_webhook_signature</symbol>
        <lines>75-149</lines>
        <reason>Current implementation validates signatures using single shared secret from settings.webhook_secret. Need to enhance to extract tenant_id from payload first, retrieve tenant-specific secret, then validate. Already uses constant-time comparison (hmac.compare_digest).</reason>
      </artifact>
      <artifact>
        <path>src/services/webhook_validator.py</path>
        <kind>service</kind>
        <symbol>validate_signature</symbol>
        <lines>22-72</lines>
        <reason>Core HMAC-SHA256 signature validation function. Computes HMAC(secret, payload_bytes) and compares with header using hmac.compare_digest(). Reusable for tenant-specific validation after extracting tenant secret.</reason>
      </artifact>
      <artifact>
        <path>src/services/tenant_service.py</path>
        <kind>service</kind>
        <symbol>TenantService</symbol>
        <lines>unknown</lines>
        <reason>Tenant configuration service for retrieving and managing tenant settings. Need to add methods: get_webhook_secret(tenant_id), rotate_webhook_secret(tenant_id). Service should use Redis caching (5-min TTL) for webhook secrets.</reason>
      </artifact>
      <artifact>
        <path>src/cache/redis_client.py</path>
        <kind>cache</kind>
        <symbol>get_tenant_config, set_tenant_config</symbol>
        <lines>84-126</lines>
        <reason>Redis caching utilities for tenant configurations with 5-minute TTL. Pattern: tenant:config:{tenant_id}. Reuse this pattern for caching webhook secrets to reduce database queries on every webhook request.</reason>
      </artifact>
      <artifact>
        <path>src/schemas/webhook.py</path>
        <kind>schema</kind>
        <symbol>WebhookPayload, ResolvedTicketWebhook</symbol>
        <lines>unknown</lines>
        <reason>Pydantic models for webhook payloads. Need to ensure tenant_id field is required and validated. Add created_at timestamp field with timezone validation for replay attack prevention.</reason>
      </artifact>
      <artifact>
        <path>src/api/webhooks.py</path>
        <kind>api</kind>
        <symbol>POST /webhook/servicedesk</symbol>
        <lines>unknown</lines>
        <reason>Webhook endpoint that currently uses Depends(validate_webhook_signature). Need to integrate new tenant-specific validation flow and rate limiting after signature validation.</reason>
      </artifact>
      <artifact>
        <path>src/utils/encryption.py</path>
        <kind>utility</kind>
        <symbol>encrypt, decrypt</symbol>
        <lines>unknown</lines>
        <reason>Encryption utilities for sensitive data in database. webhook_signing_secret_encrypted field in TenantConfig uses these functions. Verify encryption/decryption works with new secret generation flow.</reason>
      </artifact>
      <artifact>
        <path>src/utils/exceptions.py</path>
        <kind>utility</kind>
        <symbol>TenantNotFoundException</symbol>
        <lines>unknown</lines>
        <reason>Custom exceptions for tenant operations. Need to add: WebhookSignatureMismatchError, WebhookTimestampExpiredError for specific error handling in signature validation.</reason>
      </artifact>
    </code>

    <dependencies>
      <python>
        <package name="fastapi" version=">=0.104.0">Web framework with dependency injection for webhook validation</package>
        <package name="pydantic" version=">=2.5.0">Data validation and settings management, field validators for tenant_id/timestamp</package>
        <package name="sqlalchemy" version=">=2.0.23">Async ORM for tenant_configs queries</package>
        <package name="asyncpg" version=">=0.29.0">Async PostgreSQL driver</package>
        <package name="redis" version=">=5.0.1">Redis client for rate limiting and caching</package>
        <package name="loguru" version=">=0.7.2">Structured logging for security events</package>
        <package name="httpx" version=">=0.25.2">Async HTTP client (indirect dependency)</package>
        <package name="pytest" version=">=7.4.3">Testing framework for security test suite</package>
        <package name="pytest-asyncio" version=">=0.21.1">Async test support</package>
      </python>
      <system>
        <dependency name="PostgreSQL 17">Database with RLS policies for multi-tenant isolation</dependency>
        <dependency name="Redis 7.x">Message broker and cache for rate limiting sliding window</dependency>
      </system>
    </dependencies>
  </artifacts>

  <constraints>
### Development Constraints
- **Multi-Tenant Security Pattern**: Per-tenant secrets prevent cross-tenant webhook spoofing. Tenant identification happens before authentication (fail fast for unknown tenants). Signature validation is tenant-aware (secret retrieved from tenant_configs). Rate limiting isolated per tenant (Redis keys include tenant_id).

- **HMAC-SHA256 Signature Verification (2025 Best Practices)**: SHA-256 algorithm minimum (SHA-1 deprecated per Authgear 2025 guidance). Constant-time comparison using hmac.compare_digest() prevents timing attacks. Signature computed over entire request body (prevents tampering). Timestamp included in signature prevents replay attacks. Hex encoding for signature format (64 characters).

- **Defense-in-Depth Security Layers**: Layer 1: Rate limiting (prevents brute force). Layer 2: Tenant identification (404 for unknown tenants). Layer 3: Timestamp validation (prevents replay). Layer 4: Signature validation (authenticates webhook source). Layer 5: Input validation (Pydantic, from Story 3.4). Layer 6: RLS policies (from Story 3.1).

- **Existing Code Patterns to Follow**: Pydantic @field_validator for custom validation (from Story 3.4). Redis caching with 5-minute TTL (from Story 3.2). Constant-time comparison for sensitive data (from Story 3.4). Encrypted credentials in tenant_configs (from Story 3.3). SQLAlchemy async ORM with RLS context setting. Loguru structured logging with extra fields.

- **File Structure Constraints**: Webhook validation in src/services/ (established pattern). Rate limiting in src/services/ (infrastructure concern). Security tests in tests/integration/ (cross-component validation). Operational docs in docs/operations/ (new directory for Story 3.5).

### Testing Requirements
- **Comprehensive Security Test Coverage**: Minimum 20+ tests similar to Story 3.4 (45 tests, 100% pass rate). Integration tests in tests/integration/test_webhook_security.py. Unit tests for validation utilities. Parametrized tests for multiple scenarios. All security tests must pass with 100% success rate.

- **Test Fixtures Required**: test_tenant_a, test_tenant_b fixtures with different secrets. valid_webhook_payload fixture with current timestamp. Mock Redis client for rate limiting tests. Mock database session for tenant lookups.

### Performance Constraints
- **Redis Caching for Performance**: Cache webhook secrets with 5-minute TTL to reduce database queries. Use Redis sorted sets for rate limiting (ZADD, ZREMRANGEBYSCORE, ZCARD). Sliding window algorithm more accurate than fixed window. Automatic cleanup via ZREMRANGEBYSCORE and EXPIRE.

- **Rate Limiting Strategy**: Per-tenant limits prevent single tenant from DOS attack. Failed signature validations NOT counted (prevent attacker from exhausting limit). Default limit: 100 webhooks per 60-second window per tenant. Configurable per tenant in tenant_configs.rate_limits JSONB field.
  </constraints>

  <interfaces>
### API Interfaces
<interface>
  <name>validate_webhook_signature (Enhanced)</name>
  <kind>FastAPI Dependency</kind>
  <signature>async def validate_webhook_signature(request: Request, x_servicedesk_signature: str, settings: Settings) -> str</signature>
  <path>src/services/webhook_validator.py</path>
  <returns>tenant_id on successful validation, raises HTTPException(401) on failure</returns>
</interface>

<interface>
  <name>TenantConfigService.get_webhook_secret</name>
  <kind>Service Method</kind>
  <signature>async def get_webhook_secret(self, tenant_id: str) -> str</signature>
  <path>src/services/tenant_service.py</path>
  <returns>Decrypted webhook signing secret for tenant (cached in Redis, 5-min TTL)</returns>
</interface>

<interface>
  <name>check_rate_limit</name>
  <kind>Utility Function</kind>
  <signature>async def check_rate_limit(tenant_id: str, endpoint: str, limit: int = 100, window: int = 60) -> bool</signature>
  <path>src/services/rate_limiter.py (new module)</path>
  <returns>True if within limit, False if exceeded. Uses Redis sliding window with sorted set.</returns>
</interface>

<interface>
  <name>POST /webhook/servicedesk</name>
  <kind>REST Endpoint</kind>
  <signature>POST /webhook/servicedesk (Content-Type: application/json, X-ServiceDesk-Signature header required)</signature>
  <path>src/api/webhooks.py</path>
  <responses>202 Accepted (valid), 401 Unauthorized (invalid signature), 404 Not Found (unknown tenant), 429 Too Many Requests (rate limit exceeded)</responses>
</interface>

### Database Interfaces
<interface>
  <name>TenantConfig.webhook_signing_secret_encrypted</name>
  <kind>Database Field</kind>
  <signature>webhook_signing_secret_encrypted: str (TEXT, encrypted, NOT NULL)</signature>
  <path>src/database/models.py</path>
  <notes>Already exists from Story 3.3. Generated automatically during tenant creation (secrets.token_urlsafe(48) → 64 chars base64)</notes>
</interface>

<interface>
  <name>tenant_configs.rate_limits</name>
  <kind>Database Field (new)</kind>
  <signature>rate_limits: dict (JSONB, nullable, default: {"webhooks": {"ticket_created": 100, "ticket_resolved": 100}})</signature>
  <path>src/database/models.py</path>
  <notes>New field for per-tenant rate limit configuration. Alembic migration required.</notes>
</interface>

### Redis Interfaces
<interface>
  <name>webhook_rate_limit:{tenant_id}:{endpoint}</name>
  <kind>Redis Sorted Set</kind>
  <signature>ZADD key timestamp request_id, ZREMRANGEBYSCORE key 0 (now - window), ZCARD key</signature>
  <path>Redis</path>
  <notes>Sliding window rate limiter. Score = timestamp, value = request_id. Auto-expire after (window + 60) seconds.</notes>
</interface>

<interface>
  <name>tenant:config:{tenant_id}</name>
  <kind>Redis Cache</kind>
  <signature>JSON string with tenant configuration (5-minute TTL)</signature>
  <path>Redis via src/cache/redis_client.py</path>
  <notes>Existing pattern from Story 3.2. Reuse for caching webhook secrets to reduce database queries.</notes>
</interface>
  </interfaces>

  <tests>
    <standards>
The project uses Pytest with pytest-asyncio for async test support. Testing standards from Story 3.4:
- **Framework**: Pytest >=7.4.3 with pytest-asyncio >=0.21.1 for async tests
- **Location**: tests/unit/ for unit tests, tests/integration/ for integration tests
- **Fixtures**: tests/conftest.py contains shared fixtures (test database, Redis, mock tenants)
- **Patterns**: Parametrized tests for multiple scenarios (@pytest.mark.parametrize)
- **Coverage**: Story 3.4 achieved 45 tests, 100% pass rate. Target similar comprehensive coverage for webhook security (20+ tests)
- **Assertions**: Use pytest assertions, verify HTTP status codes, check Prometheus metrics incremented
- **Security Testing**: Integration tests with real HTTP requests to webhook endpoints
- **CI Integration**: Tests run in GitHub Actions, Bandit security scanning catches issues early
    </standards>

    <locations>
tests/unit/test_webhook_validator.py - Unit tests for signature validation utilities
tests/unit/test_rate_limiter.py - Unit tests for rate limiting logic
tests/integration/test_webhook_security.py - Integration tests for full webhook security flow (new file)
tests/conftest.py - Shared fixtures for tenant configs, Redis mocks, database sessions
    </locations>

    <ideas>
### Integration Tests (tests/integration/test_webhook_security.py)
- **AC1**: test_tenant_webhook_with_own_secret_accepted - Tenant A webhook with Tenant A secret → 202 Accepted
- **AC2**: test_tenant_webhook_with_different_tenant_secret_rejected - Tenant A webhook with Tenant B secret → 401 Unauthorized
- **AC3**: test_webhook_with_missing_tenant_id_rejected - Webhook payload missing tenant_id field → 422 Validation Error
- **AC3**: test_webhook_with_unknown_tenant_rejected - Webhook with unknown tenant_id → 404 Not Found
- **AC3**: test_webhook_with_inactive_tenant_rejected - Webhook with inactive tenant → 403 Forbidden
- **AC4**: test_webhook_with_missing_signature_header_rejected - Webhook without X-ServiceDesk-Signature header → 401 Unauthorized
- **AC4**: test_webhook_with_invalid_signature_format_rejected - Webhook with malformed signature (not hex) → 401 Unauthorized
- **AC5**: test_webhook_with_expired_timestamp_rejected - Webhook with timestamp 6 minutes old → 401 Unauthorized (expired)
- **AC5**: test_webhook_with_future_timestamp_rejected - Webhook with timestamp 1 minute in future → 401 Unauthorized (clock skew)
- **AC5**: test_webhook_with_naive_datetime_rejected - Webhook with naive datetime (no timezone) → 422 Validation Error
- **AC6**: test_rate_limit_allows_100_webhooks - 100 valid webhooks in 60 seconds → all accepted (202)
- **AC6**: test_rate_limit_rejects_101st_webhook - 101st webhook → 429 Too Many Requests
- **AC6**: test_rate_limit_includes_retry_after_header - 101st webhook includes Retry-After header with seconds
- **AC6**: test_rate_limit_resets_after_window - Webhook after 60-second window reset → accepted again (202)
- **AC6**: test_rate_limit_isolated_per_tenant - Tenant A rate limit doesn't affect Tenant B

### Unit Tests (tests/unit/test_webhook_validator.py)
- **AC2**: test_compute_hmac_signature_with_known_input_output - HMAC computation with known secret/payload produces expected hex digest
- **AC2**: test_secure_compare_returns_true_for_equal_strings - hmac.compare_digest returns True for identical signatures
- **AC2**: test_secure_compare_returns_false_for_different_strings - hmac.compare_digest returns False for different signatures
- **AC3**: test_extract_tenant_id_from_payload_extracts_correctly - Lightweight JSON parsing extracts tenant_id from payload
- **AC3**: test_extract_tenant_id_validates_format - tenant_id format validation (^[a-z0-9-]+$)
- **AC5**: test_validate_webhook_timestamp_rejects_expired - Timestamp validation rejects timestamps older than 5 minutes
- **AC5**: test_validate_webhook_timestamp_rejects_future - Timestamp validation rejects timestamps >30 seconds in future
- **AC5**: test_validate_webhook_timestamp_accepts_current - Current timestamp within tolerance → passes validation

### Unit Tests (tests/unit/test_rate_limiter.py)
- **AC6**: test_redis_sliding_window_increments_counter - ZADD adds request to sorted set
- **AC6**: test_redis_sliding_window_removes_expired_entries - ZREMRANGEBYSCORE removes old entries
- **AC6**: test_redis_sliding_window_returns_current_count - ZCARD returns correct count
- **AC6**: test_redis_sliding_window_sets_expiration - EXPIRE sets key TTL correctly
    </ideas>
  </tests>
</story-context>
