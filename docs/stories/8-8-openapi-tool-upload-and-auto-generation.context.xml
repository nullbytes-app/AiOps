<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>8</epicId>
    <storyId>8</storyId>
    <title>OpenAPI Tool Upload and Auto-Generation</title>
    <status>drafted</status>
    <generatedAt>2025-11-06</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/8-8-openapi-tool-upload-and-auto-generation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a system administrator</asA>
    <iWant>to upload OpenAPI/Swagger specs to auto-generate MCP tools</iWant>
    <soThat>I can integrate new APIs without writing custom code</soThat>
    <tasks>
      - Task 1: Create "Add Tool" Page UI (AC#1) - Streamlit file uploader, validation, spec preview
      - Task 2: Implement OpenAPI Parser and Validator (AC#2) - openapi-pydantic integration, version detection
      - Task 3: Extract Tool Metadata from Parsed Spec (AC#3) - base_url, auth schemes, operations list
      - Task 4: Integrate FastMCP for Dynamic MCP Tool Generation (AC#4) - FastMCP.from_openapi() auto-generation
      - Task 5: Generate Dynamic Auth Config Form (AC#5) - API Key, OAuth 2.0, Basic Auth, Bearer Token forms
      - Task 6: Implement "Test Connection" Feature (AC#6) - Healthcheck request with auth validation
      - Task 7: Create Database Schema for Tools Table (AC#7) - openapi_tools table with JSONB spec + encrypted auth
      - Task 8: Implement Tool Save Functionality (AC#7 continued) - API endpoints, service layer, Streamlit integration
      - Task 9: Implement User-Friendly Error Handling (AC#8) - Validation error formatting with line numbers
      - Task 10: Create Comprehensive Unit and Integration Tests (AC#1-8) - 50+ tests total
    </tasks>
  </story>

  <acceptanceCriteria>
    1. "Add Tool" page with file upload accepts .yaml, .json, .yml files - UI file uploader validates file extensions and MIME types, supporting OpenAPI 2.0 (Swagger) and OpenAPI 3.0/3.1 specifications
    2. OpenAPI parser validates spec - Uploaded spec is parsed and validated using openapi-pydantic (supports both Pydantic v1.8+ and v2.x), checking required fields (openapi/swagger version, info, paths), validating path operations, and detecting spec version automatically
    3. Tool metadata extracted - Parser extracts tool name (from info.title), description (from info.description), base URL (from servers[0].url or host), authentication scheme (securitySchemes), and available operations (paths with method details)
    4. MCP tool wrapper generated dynamically using FastMCP - Uses FastMCP.from_openapi() to automatically convert the entire OpenAPI spec into MCP tools, creating one tool per API endpoint with proper parameter schemas, descriptions, and type validation
    5. Authentication config form generated based on spec - UI dynamically renders auth config form based on detected securitySchemes: API Key (header/query parameter name + value), OAuth 2.0 (client ID, client secret, token URL, scopes), Basic Auth (username, password), Bearer Token
    6. "Test Connection" button validates credentials - Executes a sample operation (first GET endpoint or healthcheck) with provided auth credentials, displays success message with response status/body or error message with failure details
    7. Tool saved to tools table with metadata - Database record created with fields: tool_name, openapi_spec (JSON blob), spec_version (2.0/3.0/3.1), base_url, auth_config_encrypted (Fernet encryption), status (active/inactive), created_at, updated_at, created_by
    8. Error handling shows user-friendly errors with line numbers - Invalid specs display validation errors with specific line/path references from openapi-pydantic validator, common issues detected (missing required fields, invalid references, unsupported features), suggested fixes provided
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- FastMCP Library (Context7 MCP - 2025-11-06) -->
      <doc path="EXTERNAL:Context7:/jlowin/fastmcp" title="FastMCP - Official MCP Python SDK" section="from_openapi Integration">
        - FastMCP.from_openapi(openapi_spec, client=httpx.AsyncClient()) automatically converts entire OpenAPI spec into MCP server
        - Creates one tool per API endpoint with parameter schemas, request/response validation
        - Authentication via configured httpx.AsyncClient (API key, OAuth, Basic Auth, Bearer tokens)
        - Example: mcp = FastMCP.from_openapi(openapi_spec=spec_dict, client=client, name="API Tools", base_url="https://api.example.com")
        - Eliminates manual MCP protocol boilerplate (500+ lines → 10-20 lines)
      </doc>

      <!-- openapi-pydantic Library (Context7 MCP - 2025-11-06) -->
      <doc path="EXTERNAL:Context7:/mike-oakley/openapi-pydantic" title="openapi-pydantic - Pydantic-based OpenAPI Parser" section="Parsing and Validation">
        - Supports Pydantic v1.8+ and v2.x with compatibility layer
        - Supports OpenAPI 3.0 (v3_0 imports), 3.1 (v3_1 imports), and Swagger 2.0
        - Version detection: Check 'openapi' field (3.x) vs 'swagger' field (2.0)
        - Serialization: ALWAYS use model_dump_json(by_alias=True, exclude_none=True) for Pydantic v2
        - Field aliases avoid Python reserved words: param_in→in, media_type_schema→schema, ref→$ref
      </doc>

      <!-- Architecture Documentation -->
      <doc path="docs/architecture.md" title="AI Agents Platform Architecture" section="Admin UI Framework (ADR-009)">
        - Streamlit 1.30+ selected for admin/operations UI (Epic 6)
        - Rapid development: 5-10x faster than React, perfect for ops tools and internal dashboards
        - Separate Streamlit app (src/admin/app.py) independent of FastAPI
        - Multi-page structure: src/admin/pages/*.py with numbered prefixes
        - File upload patterns: st.file_uploader(type=['yaml', 'yml', 'json'])
      </doc>

      <!-- Plugin Architecture -->
      <doc path="docs/plugin-architecture.md" title="Plugin Architecture Overview" section="Extensible Tool Registration">
        - Epic 7 implements plugin architecture for multi-tool support (ServiceDesk Plus, Jira, future tools)
        - All plugins implement TicketingToolPlugin ABC with 4 methods
        - Extensible design enables adding new tools without modifying core enhancement logic
        - Plugin registration patterns applicable to dynamic tool generation
      </doc>

      <!-- Database Schema -->
      <doc path="docs/database-schema.md" title="Database Schema" section="Encryption Patterns">
        - Fernet encryption for sensitive credentials (servicedesk_api_key_encrypted, jira_api_token_encrypted, webhook_signing_secret_encrypted)
        - BYTEA columns for encrypted data (PostgreSQL 17)
        - Encryption key stored in Kubernetes Secret, never in database
        - Application-layer encryption/decryption with cryptography.fernet
      </doc>

      <!-- Story 8.7 Patterns -->
      <doc path="docs/stories/8-7-tool-assignment-ui.md" title="Story 8.7: Tool Assignment UI" section="Streamlit UI Patterns and Helper Functions">
        - Async helper functions: Pattern async def operation_async(...) → T, then async_to_sync(operation_async)(...) in Streamlit
        - Expandable UI sections: Use st.expander for spec preview, validation errors, generated tool lists
        - Session state management: Store uploaded file, parsed spec, auth config for workflow persistence
        - Dynamic form generation: Build form fields programmatically based on data (auth schemes similar to tool checkboxes)
        - 2025 Streamlit features: st.pills for badges, st.expander, @st.cache_data(ttl=N)
      </doc>

      <!-- Story 6.3 Encryption Patterns -->
      <doc path="docs/stories/6-3-create-tenant-management-interface.md" title="Story 6.3: Tenant Management Interface" section="Fernet Encryption Implementation">
        - get_fernet_cipher() → Fernet: Get cipher instance using TENANT_ENCRYPTION_KEY from env/secrets
        - encrypt_field(plaintext: str) → str: Encrypt sensitive field value, return base64 string
        - decrypt_field(ciphertext: str) → str: Decrypt sensitive field value
        - mask_sensitive_field(value: str, visible_chars: int = 4) → str: Mask showing only last N chars
        - Encryption service reusable for auth_config encryption in this story
      </doc>
    </docs>
    <code>
      <!-- Encryption Service (Story 6.3) -->
      <file path="src/admin/utils/tenant_helper.py" kind="service" symbol="encrypt_field" lines="79-99" reason="Fernet encryption pattern to reuse for auth_config encryption">
        - get_fernet_cipher() → Fernet: Gets cipher from TENANT_ENCRYPTION_KEY env var
        - encrypt_field(plaintext: str) → str: Returns base64-encoded ciphertext
        - decrypt_field(ciphertext: str) → str: Decrypts and returns plaintext
        - Pattern to reuse: cipher.encrypt(plaintext.encode()).decode()
      </file>

      <!-- Admin Helper Functions (Story 8.7) -->
      <file path="src/admin/utils/agent_helpers.py" kind="helper" symbol="async_to_sync" lines="520-535" reason="Async helper pattern for Streamlit compatibility">
        - async_to_sync(async_func): Wrapper to call async functions from synchronous Streamlit context
        - Pattern: result = async_to_sync(fetch_data_async)(params)
        - Used for httpx async calls in Streamlit pages
      </file>

      <file path="src/admin/utils/agent_helpers.py" kind="constant" symbol="AVAILABLE_TOOLS" lines="20-30" reason="Existing tool registry pattern">
        - Dictionary of available tools with metadata (name, description, category)
        - Example: {"servicedesk_plus": {"name": "ServiceDesk Plus", ...}, "jira": {...}}
        - This story will extend with dynamic tools from openapi_tools table
      </file>

      <!-- Agent Service Pattern (Story 8.2-8.3) -->
      <file path="src/services/agent_service.py" kind="service" symbol="AgentService" lines="33-585" reason="Service layer pattern for CRUD operations">
        - Class-based service with __init__(db: AsyncSession, base_url: str)
        - Async methods: create_agent, get_agents, get_agent_by_id, update_agent, delete_agent
        - Pattern to follow for OpenAPIToolService
      </file>

      <!-- Pydantic Schema Pattern (Story 8.2-8.3) -->
      <file path="src/schemas/agent.py" kind="schema" symbol="AgentCreate" lines="194-266" reason="Pydantic v2 schema pattern with @model_validator">
        - BaseModel with Field(...) validation (min_length, max_length, default)
        - @model_validator(mode="after") for cross-field validation
        - ConfigDict with json_schema_extra for OpenAPI examples
        - Pattern to follow for OpenAPIToolCreate/OpenAPIToolUpdate schemas
      </file>

      <!-- FastAPI Router Pattern (Story 8.3) -->
      <file path="src/api/agents.py" kind="api" symbol="@router.post" lines="37-130" reason="FastAPI async endpoint pattern">
        - @router.post("/api/agents", response_model=AgentResponse)
        - async def create_agent(agent: AgentCreate, db: AsyncSession = Depends(get_db))
        - Service layer calls: service = AgentService(db, base_url)
        - Pattern to follow for POST /api/openapi-tools
      </file>

      <!-- Streamlit Multi-Page Pattern (Story 8.4) -->
      <file path="src/admin/pages/05_Agent_Management.py" kind="ui" symbol="None" lines="1-50" reason="Streamlit page structure and navigation">
        - st.set_page_config(page_title, page_icon, layout="wide")
        - Multi-tab structure: create_tab, list_tab, detail_tab = st.tabs([...])
        - Session state management for form data
        - Pattern to follow for 07_Add_Tool.py
      </file>

      <!-- Database Model Pattern (Story 8.2) -->
      <file path="src/database/models.py" kind="model" symbol="Agent" lines="544-600" reason="SQLAlchemy async model pattern">
        - class Agent(Base): __tablename__ = "agents"
        - Columns: id (UUID), name (String), created_at (DateTime), etc.
        - JSONB columns for structured data (llm_config)
        - Pattern to follow for openapi_tools table
      </file>
    </code>
    <dependencies>
      <!-- Python Core Libraries -->
      <package ecosystem="python">fastapi>=0.104.0</package>
      <package ecosystem="python">uvicorn[standard]>=0.24.0</package>
      <package ecosystem="python">pydantic>=2.5.0</package>
      <package ecosystem="python">sqlalchemy[asyncio]>=2.0.23</package>
      <package ecosystem="python">alembic>=1.12.1</package>
      <package ecosystem="python">asyncpg>=0.29.0</package>
      <package ecosystem="python">httpx>=0.25.2</package>
      <package ecosystem="python">streamlit>=1.44.0</package>
      <package ecosystem="python">cryptography>=43.0.0</package>

      <!-- NEW Dependencies for this Story -->
      <package ecosystem="python">openapi-pydantic>=0.4.0 (NEW - OpenAPI parsing and validation)</package>
      <package ecosystem="python">fastmcp>=2.0.0 (NEW - MCP tool generation from OpenAPI specs)</package>

      <!-- Dev Dependencies -->
      <package ecosystem="python">pytest>=7.4.3</package>
      <package ecosystem="python">pytest-asyncio>=0.21.1</package>
      <package ecosystem="python">pytest-mock>=3.12.0</package>
      <package ecosystem="python">pytest-httpx>=0.22.0</package>
    </dependencies>
  </artifacts>

  <constraints>
    <!-- File Size Constraint -->
    - C1: File size limit - 500 lines per file maximum. Split parser, generator, and service into separate modules (openapi_parser_service.py, mcp_tool_generator.py, openapi_tool_service.py)

    <!-- Testing Requirements -->
    - C3: Comprehensive test coverage - 50+ total tests required (15 parser + 12 generator + 8 integration + 10 API + 5+ UI)

    <!-- Code Quality -->
    - C5: Type hints mandatory - All functions must include type annotations (def parse_spec(spec: dict) -> OpenAPI)
    - Black formatting - Line length 100, PEP8 compliance
    - Google-style docstrings on all functions with Args/Returns/Raises sections

    <!-- Async Patterns -->
    - C7: Async patterns - FastAPI endpoints and httpx clients use async/await
    - Streamlit compatibility - Use async_to_sync wrapper from agent_helpers.py for Streamlit pages

    <!-- UI Consistency -->
    - C8: Streamlit UI consistency - Follow Story 8.4/8.7 patterns (multi-tab, session state, expandable sections, @st.cache_data)

    <!-- Database Schema -->
    - C9: No breaking schema changes - New openapi_tools table must not modify existing tables
    - Multi-tenancy - Include tenant_id foreign key for row-level security

    <!-- Security -->
    - Encryption mandatory - auth_config must be Fernet encrypted before database storage
    - No hardcoded secrets - Use environment variables or Kubernetes secrets
    - Input validation - File size limit 5MB, MIME type validation for uploads

    <!-- 2025 Best Practices -->
    - Pydantic v2 - Use @model_validator(mode="after"), model_dump_json(by_alias=True, exclude_none=True)
    - httpx patterns - Granular timeouts (connect=5s, read=30s, write=5s, pool=5s), connection pooling
    - Streamlit 1.30+ - Use st.expander, st.spinner, @st.cache_data(ttl=N)

    <!-- MCP Integration -->
    - FastMCP.from_openapi() - Primary tool generation mechanism (eliminates manual MCP protocol implementation)
    - Auth flexibility - Support API Key (header/query), OAuth 2.0, Basic Auth, Bearer Token via httpx.AsyncClient
  </constraints>

  <interfaces>
    <!-- API Endpoints to Create -->
    <api method="POST" path="/api/openapi-tools" name="create_openapi_tool">
      - Request: OpenAPIToolCreate (tool_name, openapi_spec, spec_version, base_url, auth_config, tenant_id)
      - Response: OpenAPITool (id, tool_name, spec_version, base_url, status, created_at, tools_generated_count)
      - Logic: Parse spec → Extract metadata → Generate MCP tools → Encrypt auth → Save to DB
    </api>

    <api method="GET" path="/api/openapi-tools" name="list_openapi_tools">
      - Query params: tenant_id, status, search (optional)
      - Response: list[OpenAPITool]
      - Logic: Filter by tenant + status, search by tool_name
    </api>

    <api method="GET" path="/api/openapi-tools/{id}" name="get_openapi_tool">
      - Path param: id (int)
      - Response: OpenAPITool with full details
      - Logic: Fetch by ID, decrypt auth_config for display (masked)
    </api>

    <api method="POST" path="/api/openapi-tools/{id}/test-connection" name="test_connection">
      - Path param: id (int)
      - Request: TestConnectionRequest (optional override auth_config)
      - Response: TestConnectionResponse (success: bool, status_code, response_preview, error_message)
      - Logic: Find first GET endpoint or /health → Configure httpx with auth → Make request with 10s timeout → Return result
    </api>

    <!-- Service Layer Functions -->
    <function signature="parse_openapi_spec(spec_dict: dict) -> OpenAPI" module="src/services/openapi_parser_service.py">
      - Detect spec version (check 'openapi' vs 'swagger' field)
      - Route to openapi_pydantic.v3_0 or v3_1 parser based on version
      - Validate required fields (info, paths, openapi/swagger version)
      - Return: openapi_pydantic OpenAPI object or raise ValidationError
    </function>

    <function signature="extract_tool_metadata(openapi: OpenAPI) -> dict" module="src/services/openapi_parser_service.py">
      - Extract: tool_name (info.title), description (info.description), version (info.version)
      - Extract: base_url from servers[0].url (3.x) or host + basePath (2.0)
      - Extract: auth schemes from components.securitySchemes (3.x) or securityDefinitions (2.0)
      - Extract: operations list [{method, path, operationId, summary, parameters}]
      - Return: {tool_name, description, version, base_url, auth_schemes, operations, endpoint_count}
    </function>

    <function signature="generate_mcp_tools_from_openapi(openapi_spec: dict, auth_config: dict, base_url: str) -> FastMCP" module="src/services/mcp_tool_generator.py">
      - Configure httpx.AsyncClient with auth from auth_config (headers, params, or httpx.BasicAuth)
      - Call FastMCP.from_openapi(openapi_spec, client=http_client, name=tool_name, base_url=base_url)
      - Return: FastMCP instance with auto-generated tools (one per endpoint)
      - Handle: Unsupported features (callbacks, links) with graceful error messages
    </function>

    <function signature="render_auth_config_form(security_schemes: dict) -> dict" module="src/admin/components/tool_forms.py">
      - Detect auth type from security_schemes: apiKey, oauth2, http (basic/bearer)
      - Render form fields dynamically based on type:
        * API Key: key name input, key value input (password), location select (header/query)
        * OAuth 2.0: client_id, client_secret, token_url, scopes multiselect
        * Basic Auth: username, password (both password inputs)
        * Bearer Token: token input (password)
      - Return: {type, config_dict} stored in st.session_state['auth_config']
    </function>

    <!-- Database Table -->
    <table name="openapi_tools">
      - id (SERIAL PRIMARY KEY)
      - tool_name (VARCHAR(255) NOT NULL)
      - openapi_spec (JSONB NOT NULL)
      - spec_version (VARCHAR(10) CHECK IN ('2.0', '3.0', '3.1'))
      - base_url (TEXT NOT NULL)
      - auth_config_encrypted (BYTEA)
      - status (VARCHAR(20) DEFAULT 'active' CHECK IN ('active', 'inactive'))
      - created_at (TIMESTAMP DEFAULT NOW())
      - updated_at (TIMESTAMP DEFAULT NOW())
      - created_by (VARCHAR(100))
      - tenant_id (INTEGER REFERENCES tenants(id) ON DELETE CASCADE)
      - UNIQUE(tenant_id, tool_name)
      - Indexes: idx_openapi_tools_status, idx_openapi_tools_tenant
    </table>
  </interfaces>
  <tests>
    <standards>
      **Testing Framework:** pytest 7.4.3+ with pytest-asyncio, pytest-mock, pytest-httpx

      **Test Organization:**
      - Unit tests: tests/unit/test_*.py (fast, isolated, mocked dependencies)
      - Integration tests: tests/integration/test_*.py (real dependencies: database, Redis, httpx)
      - Test markers: @pytest.mark.unit, @pytest.mark.integration, @pytest.mark.asyncio

      **Coverage Requirements:**
      - Minimum 50+ total tests for this story
      - All acceptance criteria must have corresponding test coverage
      - Unit: 15+ OpenAPI parser + 12+ MCP generator + 8+ auth config mapping
      - Integration: 8+ full workflow scenarios + 10+ API endpoint tests

      **Testing Patterns (from existing tests):**
      - Pydantic validation: Test valid/invalid schemas with ValidationError assertions
      - Async functions: Use @pytest.mark.asyncio decorator, mock AsyncSession with pytest-asyncio
      - httpx mocking: Use pytest-httpx for mocking HTTP requests/responses
      - Service initialization: Test service creation, singleton patterns, base_url configuration
      - Error scenarios: Test ValidationError, HTTPStatusError, TimeoutError, ConnectError
      - Google-style docstrings: Include test description, test strategy, expected behavior

      **Quality Standards:**
      - Clear test names: test_{feature}_{scenario}_{expected_outcome}
      - Type hints in test functions: def test_parse_valid_spec() -> None:
      - Setup/teardown: Use pytest fixtures with autouse=True for cache clearing
      - Assertions: Specific assertions (assert result.tool_name == "API") vs general (assert result)
    </standards>
    <locations>
      - tests/unit/test_openapi_parser_service.py (NEW - 15+ tests)
      - tests/unit/test_mcp_tool_generator.py (NEW - 12+ tests)
      - tests/unit/test_openapi_tool_service.py (NEW - 10+ tests)
      - tests/integration/test_openapi_tool_workflow.py (NEW - 8+ tests)
      - tests/integration/test_openapi_tools_api.py (NEW - 10+ tests)
      - tests/manual/openapi_tool_upload_scenarios.md (NEW - manual UI test cases)
    </locations>
    <ideas>
      <!-- AC#1: File Upload Validation -->
      <test ac="AC#1" type="unit">
        - test_file_uploader_accepts_yaml_json_yml: Verify st.file_uploader accepts correct extensions
        - test_file_uploader_rejects_invalid_extensions: Verify .txt, .xml, .pdf rejected
        - test_file_size_validation_rejects_large_files: Files > 5MB rejected with error message
        - test_parse_uploaded_yaml_spec: YAML file correctly parsed to dict
        - test_parse_uploaded_json_spec: JSON file correctly parsed to dict
      </test>

      <!-- AC#2: OpenAPI Parser Validation -->
      <test ac="AC#2" type="unit">
        - test_parse_valid_swagger_2_0_spec: Petstore Swagger 2.0 parsed successfully
        - test_parse_valid_openapi_3_0_spec: GitHub OpenAPI 3.0 parsed successfully
        - test_parse_valid_openapi_3_1_spec: OpenAPI 3.1 spec parsed successfully
        - test_detect_spec_version_from_openapi_field: Detects 3.x from 'openapi' field
        - test_detect_spec_version_from_swagger_field: Detects 2.0 from 'swagger' field
        - test_parse_spec_missing_required_info_field: ValidationError raised with helpful message
        - test_parse_spec_missing_required_paths_field: ValidationError raised
        - test_parse_spec_invalid_path_operations: ValidationError for malformed operations
        - test_parse_spec_invalid_ref: ValidationError for broken $ref references
        - test_parse_malformed_yaml: Raises YAMLError with line number
        - test_parse_malformed_json: Raises JSONDecodeError with position
      </test>

      <!-- AC#3: Metadata Extraction -->
      <test ac="AC#3" type="unit">
        - test_extract_tool_name_from_info_title: Correctly extracts info.title
        - test_extract_description_from_info_description: Correctly extracts description
        - test_extract_base_url_from_servers_openapi_3x: servers[0].url for 3.x
        - test_extract_base_url_from_host_swagger_2: schemes + host + basePath for 2.0
        - test_extract_api_key_auth_scheme: Detects apiKey in securitySchemes
        - test_extract_oauth2_auth_scheme: Detects oauth2 flow and scopes
        - test_extract_operations_list: Correctly parses all paths and methods
        - test_count_total_endpoints: Accurate count of GET/POST/PUT/DELETE/PATCH operations
      </test>

      <!-- AC#4: FastMCP Tool Generation -->
      <test ac="AC#4" type="unit">
        - test_generate_mcp_tools_from_openapi_success: FastMCP.from_openapi called correctly
        - test_configure_httpx_client_with_api_key_header: Headers set for API key auth
        - test_configure_httpx_client_with_api_key_query: Params set for API key auth
        - test_configure_httpx_client_with_bearer_token: Authorization header set
        - test_configure_httpx_client_with_basic_auth: httpx.BasicAuth configured
        - test_tool_count_matches_endpoint_count: Generated tools = spec endpoints
        - test_unsupported_feature_callbacks_handled: Graceful error for callbacks
        - test_unsupported_feature_webhooks_handled: Graceful error for webhooks
      </test>

      <!-- AC#5: Dynamic Auth Config Form -->
      <test ac="AC#5" type="unit">
        - test_render_api_key_form_header: Form renders key name + value inputs for header
        - test_render_api_key_form_query: Form renders key name + value inputs for query
        - test_render_oauth2_form: Form renders client_id, client_secret, token_url, scopes
        - test_render_basic_auth_form: Form renders username + password inputs
        - test_render_bearer_token_form: Form renders token input (password type)
        - test_multiple_auth_schemes_renders_tabs: Tabs/radio for choosing auth method
        - test_auth_config_stored_in_session_state: Config dict saved to st.session_state
      </test>

      <!-- AC#6: Test Connection -->
      <test ac="AC#6" type="integration">
        - test_connection_success_with_valid_credentials: 200 status, response preview shown
        - test_connection_timeout: httpx.TimeoutException caught, user-friendly error
        - test_connection_401_unauthorized: 401 status, suggests credential check
        - test_connection_404_not_found: 404 status, suggests endpoint check
        - test_connection_500_server_error: 500 status, suggests API issue
        - test_connection_refused: ConnectError, suggests network/firewall issue
      </test>

      <!-- AC#7: Database Save -->
      <test ac="AC#7" type="integration">
        - test_save_tool_to_database: Tool record created with all fields
        - test_auth_config_encrypted_before_save: auth_config encrypted with Fernet
        - test_decrypt_auth_config_after_fetch: Decryption roundtrip successful
        - test_unique_constraint_tenant_tool_name: Duplicate tool_name raises IntegrityError
        - test_tenant_isolation: tenant_id foreign key enforced
      </test>

      <!-- AC#8: Error Handling -->
      <test ac="AC#8" type="unit">
        - test_format_validation_errors_with_line_numbers: Line numbers extracted from loc tuples
        - test_user_friendly_error_missing_required_field: Helpful message for missing 'info'
        - test_user_friendly_error_invalid_ref: Helpful message for broken $ref
        - test_detect_swagger_2_with_openapi_3_features: Detects version mismatch, suggests fix
        - test_detect_missing_servers_host: Detects missing base URL, suggests fix
        - test_detect_circular_references: Detects circular $ref, suggests fix
      </test>

      <!-- Integration: Full Workflow -->
      <test ac="AC#1-8" type="integration">
        - test_full_workflow_upload_parse_generate_save: Complete happy path end-to-end
        - test_workflow_invalid_spec_displays_errors: Invalid spec → validation errors shown
        - test_workflow_test_connection_then_save: Test connection → save tool
        - test_workflow_multiple_tools_same_tenant: Multiple tools per tenant allowed
        - test_workflow_tool_saved_with_encrypted_auth: Auth config encrypted in DB
      </test>
    </ideas>
  </tests>
</story-context>
