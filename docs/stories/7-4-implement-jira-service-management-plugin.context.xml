<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>7</epicId>
    <storyId>4</storyId>
    <title>Implement Jira Service Management Plugin</title>
    <status>drafted</status>
    <generatedAt>2025-11-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/7-4-implement-jira-service-management-plugin.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>platform engineer</asA>
    <iWant>a Jira Service Management plugin</iWant>
    <soThat>MSPs using Jira can benefit from ticket enhancement</soThat>
    <tasks>
      <task id="1" ac="#1">Create Jira Plugin Directory Structure (5 subtasks)</task>
      <task id="2" ac="#1,#4">Implement Jira Plugin Class (6 subtasks)</task>
      <task id="3" ac="#2">Implement Jira Webhook Validation Logic (6 subtasks)</task>
      <task id="4" ac="#4">Implement extract_metadata() Method (8 subtasks)</task>
      <task id="5" ac="#3">Implement Jira API Client (8 subtasks)</task>
      <task id="6" ac="#3">Implement get_ticket() Plugin Method (9 subtasks)</task>
      <task id="7" ac="#5">Implement update_ticket() Plugin Method (9 subtasks)</task>
      <task id="8" ac="#6">Update Database Schema for Jira Support (8 subtasks)</task>
      <task id="9" ac="#1">Register Jira Plugin on Application Startup (7 subtasks)</task>
      <task id="10" meta="true">Update Webhook Endpoint Documentation (4 subtasks)</task>
      <task id="11" ac="#7">Create Unit Tests for Jira Plugin Methods (21 subtasks)</task>
      <task id="12" ac="#8">Create Integration Test for End-to-End Flow (6 subtasks)</task>
      <task id="13" ac="#5">Convert Plain Text to Atlassian Document Format (7 subtasks)</task>
      <task id="14" meta="true">Update Package Exports (3 subtasks)</task>
      <task id="15" meta="true">Code Quality and Standards (6 subtasks)</task>
      <task id="16" ac="#9">Documentation Updates (7 subtasks)</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">Jira plugin created at src/plugins/jira/plugin.py implementing TicketingToolPlugin</criterion>
    <criterion id="AC2">Jira webhook signature validation implemented (HMAC-SHA256 with X-Hub-Signature header)</criterion>
    <criterion id="AC3">Jira API client implemented for: Get issue (GET /rest/api/3/issue/{issueKey}), Add comment (POST /rest/api/3/issue/{issueKey}/comment)</criterion>
    <criterion id="AC4">Metadata extraction from Jira webhook payload (project, issue key, summary, description, priority)</criterion>
    <criterion id="AC5">Enhancement comment posted to Jira issue using API</criterion>
    <criterion id="AC6">Jira-specific configuration fields added to tenant_configs: jira_url, jira_api_token, jira_project_key</criterion>
    <criterion id="AC7">Unit tests for Jira webhook validation, API calls, metadata extraction (minimum 15 tests)</criterion>
    <criterion id="AC8">Integration test: Send webhook → validate → extract metadata → get issue → add comment (end-to-end)</criterion>
    <criterion id="AC9">Documentation: Update docs/plugin-architecture.md with Jira plugin example and setup instructions</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/plugin-architecture.md</path>
        <title>Plugin Architecture Guide</title>
        <section>Overview, Architecture Pattern, Interface Specification</section>
        <snippet>Defines TicketingToolPlugin ABC with 4 abstract methods (validate_webhook, get_ticket, update_ticket, extract_metadata). Plugin Manager routes based on tenant tool_type. Epic 7 establishes multi-tool support pattern.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR034-FR037: Plugin Architecture & Multi-Tool Support</section>
        <snippet>FR034: Plugin architecture for multiple ticketing tools. FR035: Standardized plugin interface. FR036: Dynamic plugin loading by tenant config. FR037: Simultaneous multi-tool support.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>ADR-010: Plugin Architecture, Epic 7 Mapping</section>
        <snippet>ABC pattern chosen for type safety and interface enforcement. src/plugins/ directory structure. tenant_configs.tool_type enables routing. Plugin-specific dependencies supported.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 7: Plugin Architecture, Story 7.4</section>
        <snippet>Story 7.4 adds Jira Service Management plugin as second implementation validating plugin pattern. Prerequisites: Story 7.3 (ServiceDesk Plus migrated). Target: MVP v2.0 market expansion.</snippet>
      </doc>
      <doc>
        <path>Context7: Jira Platform REST API v3</path>
        <title>Jira Cloud Platform REST API v3 Documentation</title>
        <section>POST /rest/api/3/issue/{issueKey}/comment, GET /rest/api/3/issue/{issueKey}</section>
        <snippet>Add comment endpoint requires Atlassian Document Format (ADF): {"type":"doc","version":1,"content":[{"type":"paragraph","content":[{"type":"text","text":"content"}]}]}. Authentication: Bearer token. Returns 201 on success.</snippet>
      </doc>
      <doc>
        <path>Context7: HTTPX Python Client</path>
        <title>HTTPX AsyncClient Best Practices</title>
        <section>Timeouts, Connection Pooling, Async Context Management</section>
        <snippet>Granular timeouts: httpx.Timeout(connect=5.0, read=30.0, write=5.0, pool=5.0). Connection pooling: httpx.Limits(max_connections=100, max_keepalive_connections=20). Always use async context manager or call aclose().</snippet>
      </doc>
      <doc>
        <path>docs/stories/7-3-migrate-servicedesk-plus-to-plugin-architecture.md</path>
        <title>Story 7.3: ServiceDesk Plus Plugin Reference</title>
        <section>Implementation pattern, learnings, testing approach</section>
        <snippet>39/39 tests passing. Plugin structure: plugin.py (main class), api_client.py (REST client), webhook_validator.py (HMAC validation). Mypy strict: 0 errors required. httpx best practices: exponential backoff (2s,4s,8s), proper resource cleanup.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/plugins/base.py</path>
        <kind>interface</kind>
        <symbol>TicketingToolPlugin</symbol>
        <lines>51-316</lines>
        <reason>Abstract base class defining the 4 methods Jira plugin must implement: validate_webhook, get_ticket, update_ticket, extract_metadata. Contains comprehensive docstrings with examples.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/base.py</path>
        <kind>dataclass</kind>
        <symbol>TicketMetadata</symbol>
        <lines>20-48</lines>
        <reason>Standardized metadata structure that extract_metadata must return. Fields: tenant_id, ticket_id, description, priority, created_at.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/registry.py</path>
        <kind>service</kind>
        <symbol>PluginManager</symbol>
        <lines>86-369</lines>
        <reason>Singleton registry for plugin registration. Methods: register_plugin, get_plugin, discover_plugins. Used in src/main.py and src/workers/celery_app.py for Jira plugin registration.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/servicedesk_plus/plugin.py</path>
        <kind>reference-implementation</kind>
        <symbol>ServiceDeskPlusPlugin</symbol>
        <lines>31-486</lines>
        <reason>Reference implementation from Story 7.3. Demonstrates: HMAC validation pattern, httpx AsyncClient usage, TenantService integration, error handling. Jira plugin should follow same structure.</reason>
      </artifact>
      <artifact>
        <path>src/plugins/servicedesk_plus/api_client.py</path>
        <kind>reference-implementation</kind>
        <symbol>ServiceDeskAPIClient</symbol>
        <lines>full file</lines>
        <reason>Reference for API client structure. Shows: httpx.AsyncClient with granular timeouts, connection pooling, exponential backoff retry, proper resource cleanup with aclose().</reason>
      </artifact>
      <artifact>
        <path>src/plugins/servicedesk_plus/webhook_validator.py</path>
        <kind>reference-implementation</kind>
        <symbol>webhook validation helpers</symbol>
        <lines>full file</lines>
        <reason>Reference for webhook validation pattern. Shows: HMAC-SHA256 computation, constant-time comparison with hmac.compare_digest(), signature header parsing.</reason>
      </artifact>
      <artifact>
        <path>src/schemas/tenant.py</path>
        <kind>model</kind>
        <symbol>TenantConfigInternal</symbol>
        <lines>98-117</lines>
        <reason>Internal tenant config model. Must extend with optional Jira fields: jira_url, jira_api_token, jira_project_key. Already has tool_type field for plugin routing.</reason>
      </artifact>
      <artifact>
        <path>src/database/models.py</path>
        <kind>model</kind>
        <symbol>TenantConfig</symbol>
        <lines>30-127</lines>
        <reason>SQLAlchemy model for tenant_configs table. Has tool_type column (line 120) for plugin routing. Will add Jira columns via Alembic migration.</reason>
      </artifact>
      <artifact>
        <path>src/main.py</path>
        <kind>application</kind>
        <symbol>startup event</symbol>
        <lines>startup section</lines>
        <reason>FastAPI startup handler where plugins are registered. Must add JiraServiceManagementPlugin registration: manager.register_plugin("jira", jira_plugin).</reason>
      </artifact>
      <artifact>
        <path>src/workers/celery_app.py</path>
        <kind>worker</kind>
        <symbol>celery worker init</symbol>
        <lines>worker init section</lines>
        <reason>Celery worker initialization where plugins are registered. Must register Jira plugin on worker startup for enhancement processing.</reason>
      </artifact>
      <artifact>
        <path>tests/unit/test_servicedesk_plugin.py</path>
        <kind>test-reference</kind>
        <symbol>test patterns</symbol>
        <lines>full file</lines>
        <reason>Reference for unit test structure. 19 unit tests for webhook validation, metadata extraction, API operations. Use same patterns for test_jira_plugin.py.</reason>
      </artifact>
      <artifact>
        <path>tests/integration/test_plugin_manager_integration.py</path>
        <kind>test-reference</kind>
        <symbol>integration test patterns</symbol>
        <lines>full file</lines>
        <reason>Reference for integration testing. 5 tests for plugin registration, routing, end-to-end flows. Add Jira-specific integration tests here.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="httpx" version=">=0.25.2">AsyncClient for Jira REST API calls. Required features: granular timeouts, connection pooling, async context manager, exponential backoff retry.</package>
        <package name="pydantic" version=">=2.5.0">Data validation for TicketMetadata and tenant configs. BaseModel for Jira plugin configuration.</package>
        <package name="fastapi" version=">=0.104.0">Web framework for webhook endpoint. Plugin registration in startup event.</package>
        <package name="sqlalchemy" version=">=2.0.23">Database ORM for tenant_configs table. Alembic migration for Jira columns.</package>
        <package name="pytest" version=">=7.4.3">Test framework. Minimum 15 unit tests + integration tests required.</package>
        <package name="pytest-asyncio" version=">=0.21.1">Async test support for testing async plugin methods.</package>
        <package name="pytest-httpx" version=">=0.22.0">Mock HTTPX requests in unit tests. Mock Jira API responses.</package>
        <package name="pytest-mock" version=">=3.12.0">Mocking framework for TenantService, API clients, etc.</package>
      </python>
      <jira-specific>
        <requirement>No new dependencies required. Atlassian Document Format (ADF) conversion implemented as pure Python helper function.</requirement>
      </jira-specific>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="C1">File size limit: All Python files must be under 500 lines (CLAUDE.md requirement). Split large files into modules: plugin.py, api_client.py, webhook_validator.py.</constraint>
    <constraint id="C2">Type safety: Must pass mypy strict mode with 0 errors. All methods require complete type hints: Dict[str, Any], Optional, async def.</constraint>
    <constraint id="C3">Interface compliance: Must implement all 4 TicketingToolPlugin abstract methods. ABC enforces compile-time validation.</constraint>
    <constraint id="C4">Security: Use hmac.compare_digest() for constant-time signature comparison (prevent timing attacks). Never log secrets or API tokens.</constraint>
    <constraint id="C5">Backward compatibility: Existing ServiceDesk Plus tenants unaffected. Jira fields in tenant_configs are nullable (optional for non-Jira tenants).</constraint>
    <constraint id="C6">Resource cleanup: Always call await api_client.aclose() in finally blocks. Prevent connection leaks.</constraint>
    <constraint id="C7">Error handling: Return False/None on errors (don't raise). Log errors with tenant context. Retry transient failures (429, 500, 503) with exponential backoff (2s, 4s, 8s).</constraint>
    <constraint id="C8">Documentation: Google-style docstrings for all public methods. Include Examples section. Document ADF format requirements.</constraint>
    <constraint id="C9">Testing: Minimum 15 unit tests (AC7) + 1 integration test (AC8). 80%+ coverage. Test edge cases: missing fields, invalid signatures, API errors.</constraint>
    <constraint id="C10">Code quality: Black formatter, Ruff linter, Bandit security scan. PEP8 compliance. No security vulnerabilities.</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>TicketingToolPlugin.validate_webhook</name>
      <kind>async method</kind>
      <signature>async def validate_webhook(self, payload: Dict[str, Any], signature: str) -> bool</signature>
      <path>src/plugins/base.py:104-147</path>
      <description>Validate X-Hub-Signature header using HMAC-SHA256. Extract tenant_id from payload, retrieve webhook_signing_secret, compute expected signature, constant-time comparison.</description>
    </interface>
    <interface>
      <name>TicketingToolPlugin.get_ticket</name>
      <kind>async method</kind>
      <signature>async def get_ticket(self, tenant_id: str, ticket_id: str) -> Optional[Dict[str, Any]]</signature>
      <path>src/plugins/base.py:149-201</path>
      <description>Retrieve ticket from Jira: GET /rest/api/3/issue/{issueKey}. Return issue data dict or None on 404. Requires Bearer token authentication.</description>
    </interface>
    <interface>
      <name>TicketingToolPlugin.update_ticket</name>
      <kind>async method</kind>
      <signature>async def update_ticket(self, tenant_id: str, ticket_id: str, content: str) -> bool</signature>
      <path>src/plugins/base.py:203-256</path>
      <description>Post comment to Jira: POST /rest/api/3/issue/{issueKey}/comment. Convert plain text to ADF structure. Return True on success (201), False on error. Retry transient failures.</description>
    </interface>
    <interface>
      <name>TicketingToolPlugin.extract_metadata</name>
      <kind>sync method</kind>
      <signature>def extract_metadata(self, payload: Dict[str, Any]) -> TicketMetadata</signature>
      <path>src/plugins/base.py:258-316</path>
      <description>Extract standardized fields from Jira webhook: issue.key, issue.fields.summary, issue.fields.description, issue.fields.priority.name, issue.fields.created. Normalize priority to lowercase. Parse ISO 8601 timestamp.</description>
    </interface>
    <interface>
      <name>PluginManager.register_plugin</name>
      <kind>method</kind>
      <signature>def register_plugin(self, tool_type: str, plugin: TicketingToolPlugin) -> None</signature>
      <path>src/plugins/registry.py:131-177</path>
      <description>Register Jira plugin with tool_type="jira". Validates isinstance(plugin, TicketingToolPlugin). Called in main.py and celery_app.py on startup.</description>
    </interface>
    <interface>
      <name>Jira REST API: Get Issue</name>
      <kind>REST endpoint</kind>
      <signature>GET /rest/api/3/issue/{issueIdOrKey}</signature>
      <path>External: Jira Cloud Platform API</path>
      <description>Retrieve issue details. Auth: Bearer token. Returns: JSON with issue.key, issue.fields (summary, description, priority, status, created). Error codes: 404 (not found), 401 (invalid token), 403 (no permission).</description>
    </interface>
    <interface>
      <name>Jira REST API: Add Comment</name>
      <kind>REST endpoint</kind>
      <signature>POST /rest/api/3/issue/{issueIdOrKey}/comment</signature>
      <path>External: Jira Cloud Platform API</path>
      <description>Add comment to issue. Auth: Bearer token. Body: {"body": {ADF structure}}. ADF format: {"type":"doc","version":1,"content":[{"type":"paragraph","content":[{"type":"text","text":"content"}]}]}. Returns: 201 Created with comment details. Error codes: 404 (issue not found), 401 (invalid token), 400 (invalid body).</description>
    </interface>
    <interface>
      <name>TenantService</name>
      <kind>service class</kind>
      <signature>async def get_tenant_config(self, tenant_id: str) -> TenantConfigInternal</signature>
      <path>src/services/tenant_service.py</path>
      <description>Retrieve tenant configuration with decrypted credentials. Returns TenantConfigInternal with jira_url, jira_api_token (decrypted), webhook_signing_secret (decrypted), is_active. Used by all plugin methods to get tenant-specific config.</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
      <standard>Framework: pytest with pytest-asyncio for async methods, pytest-httpx for mocking HTTP</standard>
      <standard>Coverage: Minimum 80% code coverage (NFR requirement), target 90%+ for new code</standard>
      <standard>Test structure: AAA pattern (Arrange, Act, Assert). One assertion per test preferred</standard>
      <standard>Fixtures: Use pytest fixtures for plugin instances, mock clients, test payloads. Defined in conftest.py or test file</standard>
      <standard>Mocking: Mock TenantService for tenant configs, mock httpx.AsyncClient for API calls using pytest-httpx</standard>
      <standard>Async testing: Use @pytest.mark.asyncio decorator, await async methods, use AsyncMock for async dependencies</standard>
      <standard>Type safety: All tests must pass mypy strict mode. Use proper type hints in test functions</standard>
      <standard>Naming: test_{method}_{scenario} pattern (e.g., test_validate_webhook_success, test_validate_webhook_invalid_signature)</standard>
      <standard>Edge cases: Test missing fields, null values, invalid formats, timeout retries, API errors (404, 401, 500)</standard>
    </standards>
    <locations>
      <location>tests/unit/test_jira_plugin.py - Minimum 15 unit tests for Jira plugin methods</location>
      <location>tests/integration/test_jira_plugin_integration.py - End-to-end integration test</location>
      <location>tests/unit/conftest.py - Shared pytest fixtures for Jira plugin testing</location>
      <location>tests/integration/test_plugin_manager_integration.py - Add Jira plugin routing tests to existing file</location>
    </locations>
    <ideas>
      <idea ac="AC2">Test validate_webhook with valid X-Hub-Signature → returns True. Test invalid signature → returns False. Test missing tenant → returns False. Test inactive tenant → returns False. Test malformed signature header → raises ValueError.</idea>
      <idea ac="AC4">Test extract_metadata with valid Jira payload → returns TicketMetadata with correct fields. Test missing required fields (issue.key, summary) → raises ValidationError. Test priority normalization ("Highest" → "high", "Medium" → "medium"). Test null description → uses summary as fallback. Test invalid ISO 8601 timestamp → raises ValidationError.</idea>
      <idea ac="AC3">Test get_ticket: API returns 200 → returns issue dict. API returns 404 → returns None. API returns 401 → returns None and logs AuthenticationError. API timeout → retries 3 times with exponential backoff. Connection pool exhausted → handles httpx.PoolTimeout.</idea>
      <idea ac="AC5">Test update_ticket: API returns 201 → returns True. API returns 404 → returns False. API returns 500 → retries with backoff, eventually returns False. Test ADF conversion: "Hello\nWorld" → correct ADF structure with 2 paragraphs.</idea>
      <idea ac="AC8">Integration test: Create valid Jira webhook payload → call validate_webhook (True) → call extract_metadata (returns TicketMetadata) → call get_ticket (returns issue) → call update_ticket (returns True). Verify all methods work together end-to-end through PluginManager.</idea>
      <idea ac="AC7">Test suite totals: 5 webhook validation tests + 5 metadata extraction tests + 5 API operation tests + 2 ADF conversion tests + 1 integration test = 18 tests (exceeds AC7 minimum of 15).</idea>
    </ideas>
  </tests>
</story-context>
