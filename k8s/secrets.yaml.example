apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: default
type: Opaque
data:
  # PostgreSQL Credentials
  # Generate: openssl rand -base64 32
  # Base64 encode the actual value when filling in
  postgres-user: cG9zdGdyZXM=  # Example: 'postgres' in base64
  postgres-password: c2VjdXJlX3Bhc3N3b3JkXzEyMzQ1Ng==  # Example: 'secure_password_123456' - MUST be >= 12 chars

  # Redis Credentials
  # Generate: openssl rand -base64 32
  # Redis uses 'default' username in Redis 6+, password is the main secret
  redis-password: cmVkaXNfc2VjdXJlX3Bhc3M=  # Example: 'redis_secure_pass' - MUST be >= 12 chars

  # OpenAI API Key
  # Get from: https://platform.openai.com/account/api-keys
  # Format: sk-proj-... or sk-...
  openai-api-key: c2tfcHJvai1leGFtcGxlLWFwaS1rZXk=  # Example: 'sk-proj-example-api-key' - MUST be non-empty

  # Encryption Key (Fernet format)
  # Generate: python -c "from src.utils.encryption import generate_encryption_key; print(generate_encryption_key())"
  # Fernet key format: 'gAAAAABxxx...' (exactly 88 characters, base64-encoded with padding)
  encryption-key: Z0FBQUFBQnhYeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHg=  # Example: Valid Fernet key - CRITICAL for tenant config decryption

---
# INSTRUCTIONS FOR PRODUCTION DEPLOYMENT:
#
# 1. NEVER commit this file with real secrets to git. The example above contains only sample values.
#
# 2. To create actual secret values:
#
#    PostgreSQL Password:
#    $ openssl rand -base64 32
#    # Then base64 encode the result
#    $ echo -n "generated_password" | base64
#
#    Redis Password:
#    $ openssl rand -base64 32
#    # Then base64 encode the result
#    $ echo -n "generated_password" | base64
#
#    OpenAI API Key:
#    # Get from https://platform.openai.com/account/api-keys
#    # Base64 encode it:
#    $ echo -n "sk-proj-xxxxx" | base64
#
#    Encryption Key:
#    $ python -c "from src.utils.encryption import generate_encryption_key; print(generate_encryption_key())"
#    # This generates a Fernet key. Base64 encode it:
#    $ echo -n "gAAAAABxxx..." | base64
#
# 3. Copy this file to k8s/secrets.yaml (which is .gitignore'd):
#    $ cp k8s/secrets.yaml.example k8s/secrets.yaml
#
# 4. Replace the example values in k8s/secrets.yaml with your actual base64-encoded secrets.
#
# 5. Deploy the Secret to your Kubernetes cluster:
#    $ kubectl apply -f k8s/secrets.yaml
#
# 6. Verify the Secret was created:
#    $ kubectl get secret app-secrets -o yaml
#    $ kubectl describe secret app-secrets
#
# 7. Verify pod environment variables are mounted:
#    $ kubectl exec <pod-name> -- env | grep -E "POSTGRES|REDIS|OPENAI|ENCRYPTION"
#
# SECURITY NOTES:
# ===============
# - Base64 encoding is NOT encryption. These secrets are base64-encoded but transmitted and stored as-is.
# - Kubernetes stores secrets in etcd. Enable encryption at rest in etcd for additional security:
#   https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
# - Use RBAC to limit access to the 'app-secrets' Secret to authorized service accounts.
# - Never log or expose secret values in application logs or API responses.
# - Rotate secrets regularly (quarterly for API keys, every 6 months for passwords).
# - For encryption key rotation, see docs/runbooks/secret-rotation.md (complex - requires data migration).
#
# FIELD REQUIREMENTS:
# ===================
# postgres-password: >= 12 characters (cryptographically secure random)
# redis-password: >= 12 characters (cryptographically secure random)
# openai-api-key: Non-empty (format: sk-proj-... or sk-...)
# encryption-key: Valid Fernet format (88 characters, base64-encoded by cryptography library)
